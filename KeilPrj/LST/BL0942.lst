C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BL0942
OBJECT MODULE PLACED IN .\OBJ\BL0942.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\BL0942\BL0942.c BROWSE INCDIR(..\code\BL0942) DEBUG OBJECTEXTEND
                    - PRINT(.\LST\BL0942.lst) OBJECT(.\OBJ\BL0942.obj)

line level    source

   1          #include "./BL0942.H" // SPI hỗ trợ max 900kHz
   2          
   3          extern u16 time_system;
   4          u16 rd_time_tick = 0;
   5          u8 select_led_blink = RD_NONE;
   6          xdata u16 time_scan_btn_old = 0;
   7          xdata u16 time_scan_btn_new = 0;
   8          xdata u16 time_press_start = 0;
   9          xdata u16 time_count_press = 0;
  10          xdata u16 time_start_check_num_btn = 0;
  11          xdata u16 time_count_check_num_btn = 0;
  12          xdata u8 count_btn = 0; // so lan nhan
  13          xdata u8 BTN_STT_NEW = 0;
  14          xdata u8 BTN_STT_OLD = 0;
  15          xdata u8 btn_stt = 0;
  16          xdata u8 check_press = 0; // nhan don hoac nhan giu
  17          xdata u8 check_hold_btn = 0;
  18          xdata u8 have_press = 0;
  19          
  20          xdata u8 flag_start = 0;
  21          u8 rec_data[6] = {0};
  22          xdata u32 U_in;
  23          xdata u32 I_in;
  24          xdata int32_t P_in;
  25          xdata u16 temp_time_check_stuck = 0;
  26          xdata u16 start_time_check_stuck = 0;
  27          xdata u8 flag_start_check_stuck = 0;
  28          xdata u16 rd_time_loop = 0;
  29          
  30          xdata data_bl0942_t data_bl0942 = {0};
  31          // data_bl0942_t *Data_Read =&data_bl0942;
  32          data_flash_t *Read_Flash;
  33          
  34          void Blink_Led(u8 LED_PIN, u8 count_blink)
  35          {
  36   1          static u8 count = 0;
  37   1          if (rd_exceed_ms(rd_time_tick, 200) && select_led_blink != RD_NONE)
  38   1          {
  39   2              if (LED_PIN == LED_G)
  40   2              {
  41   3                  BLINK_LED(RD_LED_G);
  42   3              }
  43   2              else if (LED_PIN == LED_R)
  44   2              {
  45   3                  BLINK_LED(RD_LED_R);
  46   3              }
  47   2              count++;
  48   2              rd_time_tick = get_time_ms();
  49   2              if (rd_time_tick >= 65534)
  50   2                  rd_time_tick = 0;
  51   2              if (count == count_blink * 2)
  52   2              {
  53   3                  OFF_LED(RD_LED_G);
  54   3                  select_led_blink = RD_NONE;
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 2   

  55   3                  count = 0;
  56   3              }
  57   2          }
  58   1      }
  59          
  60          void Blink_Led_Err(void)
  61          {
  62   1          select_led_blink = LED_R;
  63   1          Blink_Led(LED_R, 3);
  64   1      }
  65          
  66          void Blink_Led_Config(void)
  67          {
  68   1          if (!Read_Flash->check_stuck_fan && select_led_blink == LED_G)
  69   1              Blink_Led(LED_G, 3);
  70   1      }
  71          
  72          void Blink_Led_Start(void)
  73          {
  74   1          u8 i = 0;
  75   1          OFF_LED(RD_LED_R);
  76   1          ON_LED(RD_LED_G);
  77   1          for (i = 0; i < 6; i++)
  78   1          {
  79   2              BLINK_LED(RD_LED_R);
  80   2              BLINK_LED(RD_LED_G);
  81   2              DelayXms(250);
  82   2          }
  83   1          OFF_LED(RD_LED_R);
  84   1          OFF_LED(RD_LED_G);
  85   1      }
  86          
  87          void RD_Init_flash(void)
  88          {
  89   1          read_all_flash();
  90   1          rd_print("header: ");
  91   1          RD_PRINT_HEX(Read_Flash->header);
  92   1          rd_print("tail: ");
  93   1          RD_PRINT_HEX(Read_Flash->tail);
  94   1          rd_print("\n");
  95   1          if (Read_Flash->header != 0x55 && Read_Flash->tail != 0xaa)
  96   1          {
  97   2              rd_print("init flash fail\n");
  98   2              Read_Flash->header = 0x55;
  99   2              Read_Flash->tail = 0xaa;
 100   2              Read_Flash->check_stuck_fan = 0;
 101   2              Read_Flash->P_old = 0; // 20;
 102   2              Read_Flash->P_stuck = Read_Flash->P_old;
 103   2              Read_Flash->I_old = 0; // 0.0992;
 104   2              Read_Flash->I_stuck = Read_Flash->I_old;
 105   2              Read_Flash->U_old = 0; // 220;
 106   2              Read_Flash->relay_stt = 1;
 107   2      
 108   2              //Read_Flash->Z_stuck = 0;
 109   2          }
 110   1          else
 111   1          {
 112   2              rd_print("init flash OK\n");
 113   2          }
 114   1          write_data_fash();
 115   1      }
 116          
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 3   

 117          uint8_t get_btn(void)
 118          {
 119   1          uint8_t temp_get_btn = 0;
 120   1          if (RD_PIN_BTN == 0)
 121   1          {
 122   2              temp_get_btn = 0;
 123   2          }
 124   1          else
 125   1          {
 126   2              temp_get_btn = 1;
 127   2          }
 128   1          return temp_get_btn;
 129   1      }
 130          
 131          u16 get_time_ms(void)
 132          {
 133   1          return time_system;
 134   1      }
 135          void RD_Scan_Btn(void)
 136          {
 137   1          u16 temp_get_time = 0;
 138   1          temp_get_time = get_time_ms();
 139   1          WDT_Clear();
 140   1          time_scan_btn_new = temp_get_time;
 141   1          if (time_scan_btn_new < time_scan_btn_old)
 142   1              time_scan_btn_old = time_scan_btn_new; // overflow
 143   1          if (time_scan_btn_new - time_scan_btn_old > 10)
 144   1          { // quet phim 10ms/1lan
 145   2              BTN_STT_NEW = get_btn();
 146   2              if (BTN_STT_NEW == 0 && BTN_STT_OLD == 1)
 147   2              { // nhan nut
 148   3                  time_press_start = temp_get_time;
 149   3                  btn_stt = 1;
 150   3              }
 151   2              else if (BTN_STT_NEW == 1 && BTN_STT_OLD == 0)
 152   2              { // nha nut
 153   3                  if (time_count_press >= 35 && time_count_press < 600)
 154   3                  {
 155   4                      if (check_hold_btn == 1)
 156   4                      {
 157   5                          rd_print("nha giu\n");
 158   5                          check_hold_btn = 0;
 159   5                      }
 160   4                      else
 161   4                      {
 162   5                          have_press = 1;
 163   5                          check_press = 1;
 164   5                      }
 165   4                  }
 166   3                  else
 167   3                  {
 168   4                      if (time_count_press >= 600)
 169   4                      {
 170   5                          rd_print("nha giu\n");
 171   5                          check_hold_btn = 0;
 172   5                      }
 173   4                  }
 174   3                  btn_stt = 0;
 175   3              }
 176   2              /*check hold btn*/
 177   2              if (btn_stt)
 178   2              {
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 4   

 179   3                  if (time_press_start > temp_get_time)
 180   3                  {
 181   4                      time_count_press = (65535 - time_press_start) + temp_get_time;
 182   4                  }
 183   3                  else
 184   3                  {
 185   4                      time_count_press = temp_get_time - time_press_start;
 186   4                  }
 187   3                  if (time_count_press >= 3000)
 188   3                  {
 189   4                      have_press = 1;
 190   4                      check_press = 2;
 191   4                      time_press_start = temp_get_time - 500; // (3000 - 500)ms scan 1 phat
 192   4                  }
 193   3              }
 194   2              BTN_STT_OLD = BTN_STT_NEW;
 195   2              time_scan_btn_old = time_scan_btn_new;
 196   2          }
 197   1          /*xu ly nut nhan*/
 198   1          if (have_press)
 199   1          {
 200   2              if (check_press == 1)
 201   2              {
 202   3                  rd_print("an ne\n");
 203   3                  time_start_check_num_btn = temp_get_time;
 204   3                  count_btn++;
 205   3                  check_press = 0;
 206   3              }
 207   2              else if (check_press == 2) // nhan giu config
 208   2              {
 209   3                  if(!Read_Flash->check_stuck_fan && RD_RELAY == 1){
 210   4                      config_P_I_Stuck();
 211   4                      select_led_blink = LED_G;
 212   4                      rd_time_tick = get_time_ms();
 213   4                  }
 214   3                  count_btn = 0;
 215   3                  check_hold_btn = 1;
 216   3                  check_press = 0;
 217   3              }
 218   2              have_press = 0;
 219   2          }
 220   1      
 221   1          /*kiem tra so lan nhan*/
 222   1          if (time_start_check_num_btn > temp_get_time)
 223   1          {
 224   2              time_count_check_num_btn = (65535 - time_start_check_num_btn) + temp_get_time;
 225   2          }
 226   1          else
 227   1          {
 228   2              time_count_check_num_btn = temp_get_time - time_start_check_num_btn;
 229   2          }
 230   1          if (count_btn)
 231   1          {
 232   2              if (time_count_check_num_btn > 600)
 233   2              {
 234   3                  if (count_btn == 1)
 235   3                  {
 236   4                      rd_print("ON OFF\n");
 237   4                      BLINK_LED(RD_RELAY);
 238   4                      OFF_LED(RD_LED_R);
 239   4                      flag_start_check_stuck = 0;
 240   4                      Read_Flash->check_stuck_fan = 0;
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 5   

 241   4                      start_time_check_stuck = temp_time_check_stuck;
 242   4                  }
 243   3                  else if (count_btn == 2)
 244   3                  {
 245   4                      rd_print("2 phat\n");
 246   4                  }
 247   3                  else if (count_btn == 3)
 248   3                  {
 249   4                      rd_print("reset module\n");
 250   4                      select_led_blink = LED_R;
 251   4                      Read_Flash->check_stuck_fan = 0;
 252   4                      flag_start_check_stuck = 0;
 253   4                      OFF_LED(RD_LED_R);
 254   4                      ON_RELAY();
 255   4                  }
 256   3                  count_btn = 0;
 257   3                  time_count_check_num_btn = 0;
 258   3                  time_start_check_num_btn = temp_get_time;
 259   3              }
 260   2          }
 261   1          else
 262   1          {
 263   2              time_start_check_num_btn = temp_get_time;
 264   2          }
 265   1      }
 266          
 267          void RD_Unlock_Send(void)
 268          {
 269   1          uint8_t data_send[6] = {0};
 270   1          uint16_t CRC_Temp = (0xA8 + USR_WRPROT + 0x55);
 271   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 272   1          data_send[0] = 0xA8;
 273   1          data_send[1] = USR_WRPROT;
 274   1          data_send[2] = 0x00;
 275   1          data_send[3] = 0x00;
 276   1          data_send[4] = 0x55;
 277   1          data_send[5] = CRC_Check;
 278   1          RD_Send_String_SPI(data_send);
 279   1      }
 280          
 281          void RD_Send_Setup(uint8_t reg_addr, uint8_t *data_w)
 282          {
 283   1          uint8_t i = 0;
 284   1          uint8_t data_send[6] = {0};
 285   1          uint16_t CRC_Temp = 0xA8 + reg_addr + data_w[0] + data_w[1] + data_w[2];
 286   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 287   1          RD_Unlock_Send();
 288   1          data_send[0] = 0xA8;
 289   1          data_send[1] = reg_addr;
 290   1          data_send[2] = data_w[0];
 291   1          data_send[3] = data_w[1];
 292   1          data_send[4] = data_w[2];
 293   1          data_send[5] = CRC_Check;
 294   1          RD_Send_String_SPI(data_send);
 295   1      
 296   1      #if RD_LOG
                  rd_print("data send: ");
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(data_send[i]);
                  }
                  rd_print("\n");
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 6   

              #endif
 304   1      }
 305          
 306          int32_t RD_Read_Data_Signed_SPI(uint8_t reg_addr)
 307          {
 308   1          u32 read_value = 0;
 309   1          uint8_t i = 0;
 310   1          uint8_t tx_data[6] = {0};
 311   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 312   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 313   1          tx_data[0] = 0x58;
 314   1          tx_data[1] = reg_addr;
 315   1          tx_data[2] = 0x00;
 316   1          tx_data[3] = 0x00;
 317   1          tx_data[4] = 0x00;
 318   1          tx_data[5] = 0x00; // CRC_Check;
 319   1          RD_Send_String_SPI(tx_data);
 320   1      
 321   1      #if RD_LOG
                  rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(rec_data[i]);
                  }
                  rd_print("\n");
              #endif
 329   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 330   1          CRC_Check = ~(CRC_Temp & 0xff);
 331   1          if (CRC_Check == rec_data[5])
 332   1          {
 333   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 334   2              memset(rec_data, 0, 6);
 335   2              if (read_value & 0x800000)
 336   2              {
 337   3                  read_value |= 0xff000000; // mo rong bit dau
 338   3              }
 339   2              // rd_print("value = %ld \n", read_value);
 340   2              // rd_print("-----------------------------\n");
 341   2              return read_value;
 342   2          }
 343   1          memset(rec_data, 0, 6);
 344   1          return 0;
 345   1      }
 346          
 347          u32 RD_Read_Data_SPI(uint8_t reg_addr)
 348          { // get data ko dau
 349   1          u32 read_value = 0;
 350   1          uint8_t i = 0;
 351   1          uint8_t tx_data[6] = {0};
 352   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 353   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 354   1          tx_data[0] = 0x58;
 355   1          tx_data[1] = reg_addr;
 356   1          tx_data[2] = 0x00;
 357   1          tx_data[3] = 0x00;
 358   1          tx_data[4] = 0x00;
 359   1          tx_data[5] = 0x00; // CRC_Check;
 360   1          RD_Send_String_SPI(tx_data);
 361   1      
 362   1      #if RD_LOG
                  rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
                  for (i = 0; i < 6; i++)
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 7   

                  {
                      RD_PRINT_HEX(rec_data[i]);
                  }
                  rd_print("\n");
              #endif
 370   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 371   1          CRC_Check = ~(CRC_Temp & 0xff);
 372   1          if (CRC_Check == rec_data[5])
 373   1          {
 374   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 375   2              memset(rec_data, 0, 6);
 376   2      #if RD_LOG
                      rd_print("value = %lu\n", read_value);
                      rd_print("-----------------------------\n");
              #endif
 380   2              return read_value;
 381   2          }
 382   1          // rd_print("-----------------------------\n");
 383   1          memset(rec_data, 0, 6);
 384   1          return 0;
 385   1      }
 386          
 387          u8 rd_exceed_ms(u16 ref, u16 span_ms)
 388          {
 389   1          return ((get_time_ms() - ref) >= span_ms);
 390   1      }
 391          
 392          void RD_setup_BL0942(void)
 393          {
 394   1          uint8_t Set_CF_ZX[3] = {0x00, 0x00, 0x23}; // 0010 0011: ZX 10, CF2 00, CF1 11
 395   1          uint8_t Set_Gain[3] = {0x00, 0x00, 0x03};
 396   1          uint8_t Set_Soft_Reset[3] = {0x5a, 0x5a, 0x5a};
 397   1          RD_Send_Setup(GAIN_CR, Set_Gain); // 0x1A
 398   1          RD_Send_Setup(SOFT_RESET, Set_Soft_Reset);//0x1C
 399   1          RD_Send_Setup(REG_OT_FUNX, Set_CF_ZX); //0x18
 400   1          rd_print("SET UP OK!\n\n\n");
 401   1      }
 402          
 403          void read_UIP(void)
 404          {
 405   1          float temp_cal;
 406   1          U_in = RD_Read_Data_SPI(REG_VRMS);
 407   1          temp_cal = 2375.72118f / (73989.0f * 510.0f); // temp_U //= (1.218*(390000*5 + 510)*0.001)
 408   1          data_bl0942.U_hd = U_in * temp_cal;
 409   1          rd_print("U hd: %.2f V, \n", data_bl0942.U_hd);
 410   1          // DelayXms(200);
 411   1      
 412   1          I_in = RD_Read_Data_SPI(REG_IRMS);
 413   1          temp_cal = 1.218 / 305978; // temp_I
 414   1          data_bl0942.I_hd = (I_in * temp_cal);
 415   1          rd_print("I hd: %.4f A, \n", data_bl0942.I_hd);
 416   1          // DelayXms(200);
 417   1      
 418   1          /* Test
 419   1              P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 420   1              temp_cal = 0.001604122;
 421   1              data_bl0942.P_hd = P_in * temp_cal;
 422   1              rd_print("P hieu dung: %.3f W \n", data_bl0942.P_hd);
 423   1      
 424   1              data_bl0942.Cos_Phi = (data_bl0942.P_hd) / ((data_bl0942.U_hd) * (data_bl0942.I_hd));
 425   1              rd_print("Cos phi : %.3f \n\n", data_bl0942.Cos_Phi);
 426   1          */
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 8   

 427   1          // data_bl0942.Z = data_bl0942.U_hd / data_bl0942.I_hd;
 428   1          // rd_print("Tro khang Z: %.3f \n\n", data_bl0942.Z);
 429   1      
 430   1          if (data_bl0942.I_hd < 0.0001)
 431   1          {
 432   2              data_bl0942.P_hd = 0;
 433   2              data_bl0942.Cos_Phi = 0;
 434   2          }
 435   1          else
 436   1          {
 437   2              P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 438   2              temp_cal = 0.001604122; //=((1.218*1.218)*(390000*5 + 510))/(3537*0.001*510*1000*1000)  temp_P
 439   2              data_bl0942.P_hd = P_in * temp_cal;
 440   2              if (data_bl0942.P_hd < 0 || data_bl0942.P_hd > 10000)
 441   2                  data_bl0942.P_hd = 0;
 442   2              // rd_print("P hieu dung: %.3f W\n\n", data_bl0942.P_hd);
 443   2          }
 444   1      }
 445          void config_P_I_Stuck(void)
 446          {
 447   1          Read_Flash->P_old = data_bl0942.P_hd;
 448   1          Read_Flash->P_stuck = Read_Flash->P_old;
 449   1          Read_Flash->I_old = data_bl0942.I_hd;
 450   1          Read_Flash->I_stuck = Read_Flash->I_old;
 451   1          Read_Flash->U_old = data_bl0942.U_hd;
 452   1          //Read_Flash->Z_old = data_bl0942.U_hd / data_bl0942.I_hd;
 453   1          //Read_Flash->Z_stuck = Read_Flash->Z_old;
 454   1          write_data_fash();
 455   1          rd_print("config P ket: %.3f W\n\n\n", Read_Flash->P_stuck);
 456   1          //rd_print("config Z ket: %.3f Ohm\n\n\n", Read_Flash->Z_stuck);
 457   1      }
 458          
 459          void update_Pstuck_by_U(void)
 460          {
 461   1          data_bl0942.Cos_Phi = data_bl0942.P_hd / (data_bl0942.U_hd * data_bl0942.I_hd);
 462   1          if (CALC_EXCEED(data_bl0942.U_hd, Read_Flash->U_old) > 3)
 463   1          { // U tang 5%
 464   2              Read_Flash->I_old = (float)(0.001609*data_bl0942.U_hd*data_bl0942.U_hd - 0.2166*data_bl0942.U_hd +
             - 69.3708)/1000;
 465   2              Read_Flash->I_stuck = Read_Flash->I_old;
 466   2              Read_Flash->P_old = 0.0006853*data_bl0942.U_hd*data_bl0942.U_hd - 0.10797*data_bl0942.U_hd + 10.81
             -47; 
 467   2              Read_Flash->P_stuck = Read_Flash->P_old;
 468   2              Read_Flash->U_old = data_bl0942.U_hd;
 469   2              // Read_Flash->Z_old = data_bl0942.U_hd / data_bl0942.I_hd;
 470   2              // Read_Flash->Z_stuck = Read_Flash->Z_old;
 471   2              write_data_fash();
 472   2              rd_print("I ket up: %.3f A\n", Read_Flash->I_stuck);
 473   2              rd_print("P ket up: %.3f W\n\n", Read_Flash->P_stuck);
 474   2          }
 475   1          else if (CALC_LESS(data_bl0942.U_hd, Read_Flash->U_old) > 3)
 476   1          { // U giam 5%
 477   2              Read_Flash->I_old = (float)(0.001609*data_bl0942.U_hd*data_bl0942.U_hd - 0.2166*data_bl0942.U_hd +
             - 69.3708)/1000;
 478   2              Read_Flash->I_stuck = Read_Flash->I_old;
 479   2              Read_Flash->P_old = 0.0006853*data_bl0942.U_hd*data_bl0942.U_hd - 0.10797*data_bl0942.U_hd + 10.81
             -47; 
 480   2              Read_Flash->P_stuck = Read_Flash->P_old;
 481   2              Read_Flash->U_old = data_bl0942.U_hd;
 482   2              // Read_Flash->Z_old = data_bl0942.U_hd / data_bl0942.I_hd;
 483   2              // Read_Flash->Z_stuck = Read_Flash->Z_old;
 484   2              write_data_fash();
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 9   

 485   2              rd_print("I ket down: %.3f A\n", Read_Flash->I_stuck);
 486   2              rd_print("P ket down: %.3f W\n\n", Read_Flash->P_stuck);
 487   2          }
 488   1          else if ((CALC_EXCEED(data_bl0942.U_hd, Read_Flash->U_old) < 1) || (CALC_LESS(data_bl0942.U_hd, Read_F
             -lash->U_old) < 1))
 489   1          {
 490   2              //Read_Flash->U_old = data_bl0942.U_hd;
 491   2           
 492   2          }
 493   1      }
 494          
 495          void loop_check_stuck_fan(void)
 496          {
 497   1          if (data_bl0942.U_hd > 100 && data_bl0942.P_hd > 5 && Read_Flash->P_old > 0)
 498   1          {
 499   2              if (start_time_check_stuck >= 65530)
 500   2                  start_time_check_stuck = 0;
 501   2              if (Read_Flash->check_stuck_fan == 0 && Read_Flash->P_old > 0)
 502   2              {
 503   3                  if (!flag_start_check_stuck)
 504   3                  {
 505   4                      if (rd_exceed_ms(start_time_check_stuck, TIMEOUT_START_CHECK))
 506   4                      {
 507   5                          start_time_check_stuck = temp_time_check_stuck;
 508   5                          flag_start_check_stuck = 1;
 509   5                          rd_print("start check stuck\n\n\n");
 510   5                      }
 511   4                  }
 512   3                  else
 513   3                  {
 514   4                      float temp_check_P = 0;
 515   4                      update_Pstuck_by_U();
 516   4                      if (data_bl0942.P_hd > Read_Flash->P_old)
 517   4                      {
 518   5                          if (data_bl0942.I_hd > Read_Flash->I_old)
 519   5                          {
 520   6                              temp_check_P = ((data_bl0942.P_hd - Read_Flash->P_old) / Read_Flash->P_stuck) * 10
             -0;
 521   6                              // if (((data_bl0942.I_hd - Read_Flash->I_old) / Read_Flash->I_stuck) * 1000 >= 5)
 522   6                              // { // I > 0.5%
 523   6                              //     temp_check_P = ((data_bl0942.P_hd - Read_Flash->P_old) / Read_Flash->P_stuc
             -k) * 100;
 524   6                              // }
 525   6                          }
 526   5                          if (data_bl0942.P_hd > Read_Flash->P_stuck && data_bl0942.I_hd > Read_Flash->I_stuck)
 527   5                          {
 528   6                              Read_Flash->P_old = Read_Flash->P_stuck;
 529   6                              Read_Flash->I_old = Read_Flash->I_stuck;
 530   6                          }
 531   5                      }
 532   4                      else
 533   4                      {
 534   5                          // neu cong suat giam 2%
 535   5                          if (((Read_Flash->P_old - data_bl0942.P_hd) / Read_Flash->P_old) * 100 < 2)
 536   5                          {
 537   6                              Read_Flash->P_old = data_bl0942.P_hd;
 538   6                              Read_Flash->I_old = data_bl0942.I_hd;
 539   6                          }
 540   5                      }
 541   4      
 542   4                      if (temp_check_P >= P_THRESHOLD)
 543   4                      {
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 10  

 544   5                          Read_Flash->check_stuck_fan = 1;
 545   5                          rd_print("delta P: %.2f \n", temp_check_P);
 546   5                          rd_print("VUOT MUC PICKLEBALL\n\n\n");
 547   5                          OFF_RELAY();
 548   5                          
 549   5                      }
 550   4                  }
 551   3              }
 552   2              else
 553   2              {
 554   3                  start_time_check_stuck = temp_time_check_stuck;
 555   3              }
 556   2          }
 557   1          else
 558   1          {
 559   2              start_time_check_stuck = temp_time_check_stuck;
 560   2              flag_start_check_stuck = 0;
 561   2          }
 562   1      }
 563          
 564          void rd_start_init(void)
 565          {
 566   1          ON_RELAY();
 567   1          Blink_Led_Start();
 568   1          DelayXms(1000);
 569   1      }
 570          
 571          void rd_loop(void)
 572          {
 573   1          temp_time_check_stuck = get_time_ms();
 574   1          if (flag_start == 0)
 575   1          {
 576   2              RD_Init_flash();
 577   2              RD_setup_BL0942();
 578   2              rd_time_loop = get_time_ms();
 579   2              flag_start = 1;
 580   2              rd_print("P ket init: %.3f W\n", Read_Flash->P_stuck);
 581   2          }
 582   1          RD_Scan_Btn();    
 583   1          if (rd_exceed_ms(rd_time_loop, TIME_LOOP))
 584   1          {
 585   2              read_UIP();
 586   2              loop_check_stuck_fan();
 587   2              rd_time_loop = get_time_ms();
 588   2              if (rd_time_loop >= 65530)
 589   2                  rd_time_loop = 0;
 590   2          }
 591   1          if (Read_Flash->check_stuck_fan == 1)
 592   1          {
 593   2              Blink_Led_Err();
 594   2          }else{
 595   2              Blink_Led_Config();
 596   2          }
 597   1      }
 598          
 599          /*
 600          void loop_check_stuck_fan_by_Z(void)
 601          {
 602              if (data_bl0942.P_hd > 10 && Read_Flash->Z_stuck > 0)
 603              {
 604                  if (start_time_check_stuck >= 65530)
 605                      start_time_check_stuck = 0;
C51 COMPILER V9.01   BL0942                                                                02/12/2025 15:59:38 PAGE 11  

 606                  if (Read_Flash->check_stuck_fan == 0)
 607                  {
 608                      if (!flag_start_check_stuck)
 609                      {
 610                          if (rd_exceed_ms(start_time_check_stuck, TIMEOUT_START_CHECK))
 611                          {
 612                              start_time_check_stuck = temp_time_check_stuck;
 613                              flag_start_check_stuck = 1;
 614                              rd_print("start check stuck\n\n\n");
 615                          }
 616                      }
 617                      else
 618                      {
 619                          update_Pstuck_by_U();
 620                          if (CALC_LESS(data_bl0942.Z, Read_Flash->Z_stuck) >= 8)
 621                          {
 622                              Read_Flash->check_stuck_fan = 1;
 623                              rd_print("tro khang: %.3f \n", data_bl0942.Z);
 624                              rd_print("VUOT MUC PICKLEBALL\n\n\n");
 625                              OFF_RELAY();
 626                          }
 627              
 628                      }
 629                  }
 630                  else
 631                  {
 632                      start_time_check_stuck = temp_time_check_stuck;
 633                  }
 634              }
 635              else
 636              {
 637                  start_time_check_stuck = temp_time_check_stuck;
 638                  flag_start_check_stuck = 0;
 639              }
 640          }
 641          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3996    ----
   CONSTANT SIZE    =    365    ----
   XDATA SIZE       =     55    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      64
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
