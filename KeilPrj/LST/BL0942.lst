C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BL0942
OBJECT MODULE PLACED IN .\OBJ\BL0942.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\BL0942\BL0942.c BROWSE INCDIR(..\code\BL0942) DEBUG OBJECTEXTEND
                    - PRINT(.\LST\BL0942.lst) OBJECT(.\OBJ\BL0942.obj)

line level    source

   1          #include "./BL0942.H" // SPI hỗ trợ max 900kHz
   2          
   3          extern u16 time_system;
   4          u16 rd_time_tick = 0;
   5          u8 select_led_blink = RD_NONE;
   6          xdata u16 time_scan_btn_old = 0;
   7          xdata u16 time_scan_btn_new = 0;
   8          xdata u16 time_press_start = 0;
   9          xdata u16 time_count_press = 0;
  10          xdata u16 time_start_check_num_btn = 0;
  11          xdata u16 time_count_check_num_btn = 0;
  12          xdata u8 count_btn = 0; // so lan nhan
  13          xdata u8 BTN_STT_NEW = 0;
  14          xdata u8 BTN_STT_OLD = 0;
  15          xdata u8 btn_stt = 0;
  16          xdata u8 check_press = 0; // nhan don hoac nhan giu
  17          xdata u8 check_hold_btn = 0;
  18          xdata u8 have_press = 0;
  19          
  20          xdata u8 flag_start = 0;
  21          u8 rec_data[6] = {0};
  22          xdata u32 U_in;
  23          xdata u32 I_in;
  24          xdata int32_t P_in;
  25          xdata u16 temp_time_check_stuck = 0;
  26          xdata u16 start_time_check_stuck = 0;
  27          xdata u8 flag_start_check_stuck = 0;
  28          xdata u16 rd_time_loop = 0;
  29          
  30          xdata data_bl0942_t data_bl0942 = {0};
  31          // data_bl0942_t *Data_Read =&data_bl0942;
  32          data_flash_t *Read_Flash;
  33          
  34          void Blink_Led(u8 LED_PIN, u8 count_blink)
  35          {
  36   1          static u8 count = 0;
  37   1          if (rd_exceed_ms(rd_time_tick, 200) && select_led_blink != RD_NONE)
  38   1          {
  39   2              if (LED_PIN == LED_G)
  40   2              {
  41   3                  BLINK_LED(RD_LED_G);
  42   3              }
  43   2              else if (LED_PIN == LED_R)
  44   2              {
  45   3                  BLINK_LED(RD_LED_R);
  46   3              }
  47   2              count++;
  48   2              rd_time_tick = get_time_ms();
  49   2              if (rd_time_tick >= 65534)
  50   2                  rd_time_tick = 0;
  51   2              if (count == count_blink * 2)
  52   2              {
  53   3                  select_led_blink = RD_NONE;
  54   3                  count = 0;
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 2   

  55   3              }
  56   2          }
  57   1      }
  58          
  59          void Blink_Led_Err(void)
  60          {
  61   1          select_led_blink = LED_R;
  62   1          Blink_Led(LED_R, 3);
  63   1      }
  64          
  65          void Blink_Led_Config(void)
  66          {
  67   1          if (!Read_Flash->check_stuck_fan && select_led_blink == LED_G)
  68   1              Blink_Led(LED_G, 3);
  69   1      }
  70          
  71          void Blink_Led_Start(void)
  72          {
  73   1          u8 i = 0;
  74   1          OFF_LED(RD_LED_R);
  75   1          ON_LED(RD_LED_G);
  76   1          for (i = 0; i < 6; i++)
  77   1          {
  78   2              BLINK_LED(RD_LED_R);
  79   2              BLINK_LED(RD_LED_G);
  80   2              DelayXms(250);
  81   2          }
  82   1          OFF_LED(RD_LED_R);
  83   1          OFF_LED(RD_LED_G);
  84   1      }
  85          
  86          void RD_Init_flash(void)
  87          {
  88   1          read_all_flash();
  89   1          rd_print("header: ");
  90   1          RD_PRINT_HEX(Read_Flash->header);
  91   1          rd_print("tail: ");
  92   1          RD_PRINT_HEX(Read_Flash->tail);
  93   1          rd_print("\n");
  94   1          if (Read_Flash->header != 0x55 && Read_Flash->tail != 0xaa)
  95   1          {
  96   2              rd_print("init flash fail\n");
  97   2              Read_Flash->header = 0x55;
  98   2              Read_Flash->tail = 0xaa;
  99   2              Read_Flash->check_stuck_fan = 0;
 100   2              Read_Flash->P_old = 0; // 20;
 101   2              Read_Flash->P_stuck = Read_Flash->P_old;
 102   2              Read_Flash->I_old = 0; // 0.0992;
 103   2              Read_Flash->I_stuck = Read_Flash->I_old;
 104   2              Read_Flash->U_old = 0; // 220;
 105   2              Read_Flash->relay_stt = 1;
 106   2      
 107   2              //Read_Flash->Z_stuck = 0;
 108   2          }
 109   1          else
 110   1          {
 111   2              rd_print("init flash OK\n");
 112   2          }
 113   1          write_data_fash();
 114   1      }
 115          
 116          uint8_t get_btn(void)
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 3   

 117          {
 118   1          uint8_t temp_get_btn = 0;
 119   1          if (RD_PIN_BTN == 0)
 120   1          {
 121   2              temp_get_btn = 0;
 122   2          }
 123   1          else
 124   1          {
 125   2              temp_get_btn = 1;
 126   2          }
 127   1          return temp_get_btn;
 128   1      }
 129          
 130          u16 get_time_ms(void)
 131          {
 132   1          return time_system;
 133   1      }
 134          void RD_Scan_Btn(void)
 135          {
 136   1          u16 temp_get_time = 0;
 137   1          temp_get_time = get_time_ms();
 138   1          WDT_Clear();
 139   1          time_scan_btn_new = temp_get_time;
 140   1          if (time_scan_btn_new < time_scan_btn_old)
 141   1              time_scan_btn_old = time_scan_btn_new; // overflow
 142   1          if (time_scan_btn_new - time_scan_btn_old > 10)
 143   1          { // quet phim 10ms/1lan
 144   2              BTN_STT_NEW = get_btn();
 145   2              if (BTN_STT_NEW == 0 && BTN_STT_OLD == 1)
 146   2              { // nhan nut
 147   3                  time_press_start = temp_get_time;
 148   3                  btn_stt = 1;
 149   3              }
 150   2              else if (BTN_STT_NEW == 1 && BTN_STT_OLD == 0)
 151   2              { // nha nut
 152   3                  if (time_count_press >= 35 && time_count_press < 600)
 153   3                  {
 154   4                      if (check_hold_btn == 1)
 155   4                      {
 156   5                          rd_print("nha giu\n");
 157   5                          check_hold_btn = 0;
 158   5                      }
 159   4                      else
 160   4                      {
 161   5                          have_press = 1;
 162   5                          check_press = 1;
 163   5                      }
 164   4                  }
 165   3                  else
 166   3                  {
 167   4                      if (time_count_press >= 600)
 168   4                      {
 169   5                          rd_print("nha giu\n");
 170   5                          check_hold_btn = 0;
 171   5                      }
 172   4                  }
 173   3                  btn_stt = 0;
 174   3              }
 175   2              /*check hold btn*/
 176   2              if (btn_stt)
 177   2              {
 178   3                  if (time_press_start > temp_get_time)
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 4   

 179   3                  {
 180   4                      time_count_press = (65535 - time_press_start) + temp_get_time;
 181   4                  }
 182   3                  else
 183   3                  {
 184   4                      time_count_press = temp_get_time - time_press_start;
 185   4                  }
 186   3                  if (time_count_press >= 3000)
 187   3                  {
 188   4                      have_press = 1;
 189   4                      check_press = 2;
 190   4                      time_press_start = temp_get_time - 1000; // (3000 - 1000)ms scan 1 phat
 191   4                  }
 192   3              }
 193   2              BTN_STT_OLD = BTN_STT_NEW;
 194   2              time_scan_btn_old = time_scan_btn_new;
 195   2          }
 196   1          /*xu ly nut nhan*/
 197   1          if (have_press)
 198   1          {
 199   2              if (check_press == 1)
 200   2              {
 201   3                  rd_print("an ne\n");
 202   3                  time_start_check_num_btn = temp_get_time;
 203   3                  count_btn++;
 204   3                  check_press = 0;
 205   3              }
 206   2              else if (check_press == 2)
 207   2              {
 208   3                  if(!Read_Flash->check_stuck_fan){
 209   4                      config_P_I_Stuck();
 210   4                      select_led_blink = LED_G;
 211   4                  }
 212   3                  count_btn = 0;
 213   3                  check_hold_btn = 1;
 214   3                  check_press = 0;
 215   3              }
 216   2              have_press = 0;
 217   2          }
 218   1      
 219   1          /*kiem tra so lan nhan*/
 220   1          if (time_start_check_num_btn > temp_get_time)
 221   1          {
 222   2              time_count_check_num_btn = (65535 - time_start_check_num_btn) + temp_get_time;
 223   2          }
 224   1          else
 225   1          {
 226   2              time_count_check_num_btn = temp_get_time - time_start_check_num_btn;
 227   2          }
 228   1          if (count_btn)
 229   1          {
 230   2              if (time_count_check_num_btn > 600)
 231   2              {
 232   3                  if (count_btn == 1)
 233   3                  {
 234   4                      rd_print("1 phat\n");
 235   4                  }
 236   3                  else if (count_btn == 2)
 237   3                  {
 238   4                      rd_print("2 phat\n");
 239   4                  }
 240   3                  else if (count_btn == 3)
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 5   

 241   3                  {
 242   4                      rd_print("reset chip ne\n");
 243   4                      select_led_blink = LED_R;
 244   4                      Read_Flash->check_stuck_fan = 0;
 245   4                      flag_start_check_stuck = 0;
 246   4                      OFF_LED(RD_LED_R);
 247   4                      ON_RELAY();
 248   4                  }
 249   3                  count_btn = 0;
 250   3                  time_count_check_num_btn = 0;
 251   3                  time_start_check_num_btn = temp_get_time;
 252   3              }
 253   2          }
 254   1          else
 255   1          {
 256   2              time_start_check_num_btn = temp_get_time;
 257   2          }
 258   1      }
 259          
 260          void RD_Unlock_Send(void)
 261          {
 262   1          uint8_t data_send[6] = {0};
 263   1          uint16_t CRC_Temp = (0xA8 + USR_WRPROT + 0x55);
 264   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 265   1          data_send[0] = 0xA8;
 266   1          data_send[1] = USR_WRPROT;
 267   1          data_send[2] = 0x00;
 268   1          data_send[3] = 0x00;
 269   1          data_send[4] = 0x55;
 270   1          data_send[5] = CRC_Check;
 271   1          RD_Send_String_SPI(data_send);
 272   1      }
 273          
 274          void RD_Send_Setup(uint8_t reg_addr, uint8_t *data_w)
 275          {
 276   1          uint8_t i = 0;
 277   1          uint8_t data_send[6] = {0};
 278   1          uint16_t CRC_Temp = 0xA8 + reg_addr + data_w[0] + data_w[1] + data_w[2];
 279   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 280   1          RD_Unlock_Send();
 281   1          data_send[0] = 0xA8;
 282   1          data_send[1] = reg_addr;
 283   1          data_send[2] = data_w[0];
 284   1          data_send[3] = data_w[1];
 285   1          data_send[4] = data_w[2];
 286   1          data_send[5] = CRC_Check;
 287   1          RD_Send_String_SPI(data_send);
 288   1      
 289   1      #if RD_LOG
                  rd_print("data send: ");
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(data_send[i]);
                  }
                  rd_print("\n");
              #endif
 297   1      }
 298          
 299          int32_t RD_Read_Data_Signed_SPI(uint8_t reg_addr)
 300          {
 301   1          u32 read_value = 0;
 302   1          uint8_t i = 0;
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 6   

 303   1          uint8_t tx_data[6] = {0};
 304   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 305   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 306   1          tx_data[0] = 0x58;
 307   1          tx_data[1] = reg_addr;
 308   1          tx_data[2] = 0x00;
 309   1          tx_data[3] = 0x00;
 310   1          tx_data[4] = 0x00;
 311   1          tx_data[5] = 0x00; // CRC_Check;
 312   1          RD_Send_String_SPI(tx_data);
 313   1      
 314   1      #if RD_LOG
                  rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(rec_data[i]);
                  }
                  rd_print("\n");
              #endif
 322   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 323   1          CRC_Check = ~(CRC_Temp & 0xff);
 324   1          if (CRC_Check == rec_data[5])
 325   1          {
 326   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 327   2              memset(rec_data, 0, 6);
 328   2              if (read_value & 0x800000)
 329   2              {
 330   3                  read_value |= 0xff000000; // mo rong bit dau
 331   3              }
 332   2              // rd_print("value = %ld \n", read_value);
 333   2              // rd_print("-----------------------------\n");
 334   2              return read_value;
 335   2          }
 336   1          memset(rec_data, 0, 6);
 337   1          return 0;
 338   1      }
 339          
 340          u32 RD_Read_Data_SPI(uint8_t reg_addr)
 341          { // get data ko dau
 342   1          u32 read_value = 0;
 343   1          uint8_t i = 0;
 344   1          uint8_t tx_data[6] = {0};
 345   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 346   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 347   1          tx_data[0] = 0x58;
 348   1          tx_data[1] = reg_addr;
 349   1          tx_data[2] = 0x00;
 350   1          tx_data[3] = 0x00;
 351   1          tx_data[4] = 0x00;
 352   1          tx_data[5] = 0x00; // CRC_Check;
 353   1          RD_Send_String_SPI(tx_data);
 354   1      
 355   1      #if RD_LOG
                  rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(rec_data[i]);
                  }
                  rd_print("\n");
              #endif
 363   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 364   1          CRC_Check = ~(CRC_Temp & 0xff);
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 7   

 365   1          if (CRC_Check == rec_data[5])
 366   1          {
 367   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 368   2              memset(rec_data, 0, 6);
 369   2      #if RD_LOG
                      rd_print("value = %lu\n", read_value);
                      rd_print("-----------------------------\n");
              #endif
 373   2              return read_value;
 374   2          }
 375   1          // rd_print("-----------------------------\n");
 376   1          memset(rec_data, 0, 6);
 377   1          return 0;
 378   1      }
 379          
 380          u8 rd_exceed_ms(u16 ref, u16 span_ms)
 381          {
 382   1          return ((get_time_ms() - ref) >= span_ms);
 383   1      }
 384          
 385          void RD_setup_BL0942(void)
 386          {
 387   1          uint8_t Set_CF_ZX[3] = {0x00, 0x00, 0x23}; // 0010 0011: ZX 10, CF2 00, CF1 11
 388   1          uint8_t Set_Gain[3] = {0x00, 0x00, 0x03};
 389   1          uint8_t Set_Soft_Reset[3] = {0x5a, 0x5a, 0x5a};
 390   1          RD_Send_Setup(GAIN_CR, Set_Gain); // 0x1A
 391   1          RD_Send_Setup(SOFT_RESET, Set_Soft_Reset);//0x1C
 392   1          RD_Send_Setup(REG_OT_FUNX, Set_CF_ZX); //0x18
 393   1          rd_print("SET UP OK!\n\n\n");
 394   1      }
 395          
 396          void read_UIP(void)
 397          {
 398   1          float temp_cal;
 399   1          U_in = RD_Read_Data_SPI(REG_VRMS);
 400   1          temp_cal = 2375.72118f / (73989.0f * 510.0f); // temp_U //= (1.218*(390000*5 + 510)*0.001)
 401   1          data_bl0942.U_hd = U_in * temp_cal;
 402   1          rd_print("U hd: %.2f V, \n", data_bl0942.U_hd);
 403   1          // DelayXms(200);
 404   1      
 405   1          I_in = RD_Read_Data_SPI(REG_IRMS);
 406   1          temp_cal = 1.218 / 305978; // temp_I
 407   1          data_bl0942.I_hd = (I_in * temp_cal);
 408   1          rd_print("I hd: %.4f A, \n", data_bl0942.I_hd);
 409   1          // DelayXms(200);
 410   1      
 411   1          /* Test
 412   1              P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 413   1              temp_cal = 0.001604122;
 414   1              data_bl0942.P_hd = P_in * temp_cal;
 415   1              rd_print("P hieu dung: %.3f W \n", data_bl0942.P_hd);
 416   1      
 417   1              data_bl0942.Cos_Phi = (data_bl0942.P_hd) / ((data_bl0942.U_hd) * (data_bl0942.I_hd));
 418   1              rd_print("Cos phi : %.3f \n\n", data_bl0942.Cos_Phi);
 419   1          */
 420   1          // data_bl0942.Z = data_bl0942.U_hd / data_bl0942.I_hd;
 421   1          // rd_print("Tro khang Z: %.3f \n\n", data_bl0942.Z);
 422   1      
 423   1          if (data_bl0942.I_hd < 0.0001)
 424   1          {
 425   2              data_bl0942.P_hd = 0;
 426   2              data_bl0942.Cos_Phi = 0;
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 8   

 427   2          }
 428   1          else
 429   1          {
 430   2              P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 431   2              temp_cal = 0.001604122; //=((1.218*1.218)*(390000*5 + 510))/(3537*0.001*510*1000*1000)  temp_P
 432   2              data_bl0942.P_hd = P_in * temp_cal;
 433   2              if (data_bl0942.P_hd < 0 || data_bl0942.P_hd > 10000)
 434   2                  data_bl0942.P_hd = 0;
 435   2              // rd_print("P hieu dung: %.3f W\n\n", data_bl0942.P_hd);
 436   2          }
 437   1      }
 438          void config_P_I_Stuck(void)
 439          {
 440   1          Read_Flash->P_old = data_bl0942.P_hd;
 441   1          Read_Flash->P_stuck = Read_Flash->P_old;
 442   1          Read_Flash->I_old = data_bl0942.I_hd;
 443   1          Read_Flash->I_stuck = Read_Flash->I_old;
 444   1          Read_Flash->U_old = data_bl0942.U_hd;
 445   1          //Read_Flash->Z_old = data_bl0942.U_hd / data_bl0942.I_hd;
 446   1          //Read_Flash->Z_stuck = Read_Flash->Z_old;
 447   1          write_data_fash();
 448   1          rd_print("config P ket: %.3f W\n\n\n", Read_Flash->P_stuck);
 449   1          //rd_print("config Z ket: %.3f Ohm\n\n\n", Read_Flash->Z_stuck);
 450   1      }
 451          
 452          void update_Pstuck_by_U(void)
 453          {
 454   1          data_bl0942.Cos_Phi = data_bl0942.P_hd / (data_bl0942.U_hd * data_bl0942.I_hd);
 455   1          if (CALC_EXCEED(data_bl0942.U_hd, Read_Flash->U_old) > 5)
 456   1          { // U tang 5%
 457   2              Read_Flash->I_old = (float)(0.001609*data_bl0942.U_hd*data_bl0942.U_hd - 0.2166*data_bl0942.U_hd +
             - 69.3708)/1000;
 458   2              Read_Flash->I_stuck = Read_Flash->I_old;
 459   2              Read_Flash->P_old = 0.0006853*data_bl0942.U_hd*data_bl0942.U_hd - 0.10797*data_bl0942.U_hd + 10.81
             -47; 
 460   2              Read_Flash->P_stuck = Read_Flash->P_old;
 461   2              Read_Flash->U_old = data_bl0942.U_hd;
 462   2              // Read_Flash->Z_old = data_bl0942.U_hd / data_bl0942.I_hd;
 463   2              // Read_Flash->Z_stuck = Read_Flash->Z_old;
 464   2              write_data_fash();
 465   2              rd_print("I ket up: %.3f A\n", Read_Flash->I_stuck);
 466   2              rd_print("P ket up: %.3f W\n\n", Read_Flash->P_stuck);
 467   2          }
 468   1          else if (CALC_LESS(data_bl0942.U_hd, Read_Flash->U_old) > 5)
 469   1          { // U giam 5%
 470   2              Read_Flash->I_old = (float)(0.001609*data_bl0942.U_hd*data_bl0942.U_hd - 0.2166*data_bl0942.U_hd +
             - 69.3708)/1000;
 471   2              Read_Flash->I_stuck = Read_Flash->I_old;
 472   2              Read_Flash->P_old = 0.0006853*data_bl0942.U_hd*data_bl0942.U_hd - 0.10797*data_bl0942.U_hd + 10.81
             -47; 
 473   2              Read_Flash->P_stuck = Read_Flash->P_old;
 474   2              Read_Flash->U_old = data_bl0942.U_hd;
 475   2              // Read_Flash->Z_old = data_bl0942.U_hd / data_bl0942.I_hd;
 476   2              // Read_Flash->Z_stuck = Read_Flash->Z_old;
 477   2              write_data_fash();
 478   2              rd_print("I ket down: %.3f A\n", Read_Flash->I_stuck);
 479   2              rd_print("P ket down: %.3f W\n\n", Read_Flash->P_stuck);
 480   2          }
 481   1          else if ((CALC_EXCEED(data_bl0942.U_hd, Read_Flash->U_old) < 1) || (CALC_LESS(data_bl0942.U_hd, Read_F
             -lash->U_old) < 1))
 482   1          {
 483   2              Read_Flash->U_old = data_bl0942.U_hd;
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 9   

 484   2              // Read_Flash->I_old = data_bl0942.I_hd;
 485   2          }
 486   1      }
 487          
 488          void loop_check_stuck_fan(void)
 489          {
 490   1          if (data_bl0942.P_hd > 5 && Read_Flash->P_old > 0)
 491   1          {
 492   2              if (start_time_check_stuck >= 65530)
 493   2                  start_time_check_stuck = 0;
 494   2              if (Read_Flash->check_stuck_fan == 0 && Read_Flash->P_old > 0)
 495   2              {
 496   3                  if (!flag_start_check_stuck)
 497   3                  {
 498   4                      if (rd_exceed_ms(start_time_check_stuck, TIMEOUT_START_CHECK))
 499   4                      {
 500   5                          start_time_check_stuck = temp_time_check_stuck;
 501   5                          flag_start_check_stuck = 1;
 502   5                          rd_print("start check stuck\n\n\n");
 503   5                      }
 504   4                  }
 505   3                  else
 506   3                  {
 507   4                      float temp_check_P = 0;
 508   4                      update_Pstuck_by_U();
 509   4                      if (data_bl0942.P_hd > Read_Flash->P_old)
 510   4                      {
 511   5                          if (data_bl0942.I_hd > Read_Flash->I_old)
 512   5                          {
 513   6                              temp_check_P = ((data_bl0942.P_hd - Read_Flash->P_old) / Read_Flash->P_stuck) * 10
             -0;
 514   6                              // if (((data_bl0942.I_hd - Read_Flash->I_old) / Read_Flash->I_stuck) * 1000 >= 5)
 515   6                              // { // I > 0.5%
 516   6                              //     temp_check_P = ((data_bl0942.P_hd - Read_Flash->P_old) / Read_Flash->P_stuc
             -k) * 100;
 517   6                              // }
 518   6                          }
 519   5                          if (data_bl0942.P_hd > Read_Flash->P_stuck && data_bl0942.I_hd > Read_Flash->I_stuck)
 520   5                          {
 521   6                              Read_Flash->P_old = Read_Flash->P_stuck;
 522   6                              Read_Flash->I_old = Read_Flash->I_stuck;
 523   6                          }
 524   5                      }
 525   4                      else
 526   4                      {
 527   5                          // neu cong suat giam 2%
 528   5                          if (((Read_Flash->P_old - data_bl0942.P_hd) / Read_Flash->P_old) * 100 < 2)
 529   5                          {
 530   6                              Read_Flash->P_old = data_bl0942.P_hd;
 531   6                              Read_Flash->I_old = data_bl0942.I_hd;
 532   6                          }
 533   5                      }
 534   4      
 535   4                      if (temp_check_P >= P_THRESHOLD)
 536   4                      {
 537   5                          Read_Flash->check_stuck_fan = 1;
 538   5                          rd_print("delta P: %.2f \n", temp_check_P);
 539   5                          rd_print("VUOT MUC PICKLEBALL\n\n\n");
 540   5                          OFF_RELAY();
 541   5                      }
 542   4                  }
 543   3              }
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 10  

 544   2              else
 545   2              {
 546   3                  start_time_check_stuck = temp_time_check_stuck;
 547   3              }
 548   2          }
 549   1          else
 550   1          {
 551   2              start_time_check_stuck = temp_time_check_stuck;
 552   2              flag_start_check_stuck = 0;
 553   2          }
 554   1      }
 555          
 556          void rd_start_init(void)
 557          {
 558   1          ON_RELAY();
 559   1          Blink_Led_Start();
 560   1          DelayXms(1000);
 561   1      }
 562          
 563          void rd_loop(void)
 564          {
 565   1          temp_time_check_stuck = get_time_ms();
 566   1          if (flag_start == 0)
 567   1          {
 568   2              RD_Init_flash();
 569   2              RD_setup_BL0942();
 570   2              rd_time_loop = get_time_ms();
 571   2              flag_start = 1;
 572   2              rd_print("P ket init: %.3f W\n", Read_Flash->P_stuck);
 573   2          }
 574   1          RD_Scan_Btn();
 575   1          Blink_Led_Config();
 576   1          if (rd_exceed_ms(rd_time_loop, TIME_LOOP))
 577   1          {
 578   2              read_UIP();
 579   2              loop_check_stuck_fan();
 580   2              rd_time_loop = get_time_ms();
 581   2              if (rd_time_loop >= 65530)
 582   2                  rd_time_loop = 0;
 583   2          }
 584   1          if (Read_Flash->check_stuck_fan == 1)
 585   1          {
 586   2              Blink_Led_Err();
 587   2          }
 588   1      }
 589          
 590          /*
 591          void loop_check_stuck_fan_by_Z(void)
 592          {
 593              if (data_bl0942.P_hd > 10 && Read_Flash->Z_stuck > 0)
 594              {
 595                  if (start_time_check_stuck >= 65530)
 596                      start_time_check_stuck = 0;
 597                  if (Read_Flash->check_stuck_fan == 0)
 598                  {
 599                      if (!flag_start_check_stuck)
 600                      {
 601                          if (rd_exceed_ms(start_time_check_stuck, TIMEOUT_START_CHECK))
 602                          {
 603                              start_time_check_stuck = temp_time_check_stuck;
 604                              flag_start_check_stuck = 1;
 605                              rd_print("start check stuck\n\n\n");
C51 COMPILER V9.01   BL0942                                                                02/11/2025 10:28:09 PAGE 11  

 606                          }
 607                      }
 608                      else
 609                      {
 610                          update_Pstuck_by_U();
 611                          if (CALC_LESS(data_bl0942.Z, Read_Flash->Z_stuck) >= 8)
 612                          {
 613                              Read_Flash->check_stuck_fan = 1;
 614                              rd_print("tro khang: %.3f \n", data_bl0942.Z);
 615                              rd_print("VUOT MUC PICKLEBALL\n\n\n");
 616                              OFF_RELAY();
 617                          }
 618              
 619                      }
 620                  }
 621                  else
 622                  {
 623                      start_time_check_stuck = temp_time_check_stuck;
 624                  }
 625              }
 626              else
 627              {
 628                  start_time_check_stuck = temp_time_check_stuck;
 629                  flag_start_check_stuck = 0;
 630              }
 631          }
 632          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4069    ----
   CONSTANT SIZE    =    366    ----
   XDATA SIZE       =     55    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      64
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
