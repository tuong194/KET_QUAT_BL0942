C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BL0942
OBJECT MODULE PLACED IN .\OBJ\BL0942.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\BL0942\BL0942.c BROWSE INCDIR(..\code\BL0942) DEBUG OBJECTEXTEND
                    - PRINT(.\LST\BL0942.lst) OBJECT(.\OBJ\BL0942.obj)

line level    source

   1          #include "./BL0942.H" // SPI hỗ trợ max 900kHz
   2          
   3          extern u16 time_system;
   4          xdata u16 time_scan_btn_old = 0;
   5          xdata u16 time_scan_btn_new = 0;
   6          xdata u16 time_press_start = 0;
   7          xdata u16 time_count_press = 0;
   8          xdata u16 time_start_check_num_btn = 0;
   9          xdata u16 time_count_check_num_btn = 0;
  10          xdata u8 count_btn = 0; // so lan nhan
  11          xdata u8 BTN_STT_NEW = 0;
  12          xdata u8 BTN_STT_OLD = 0;
  13          xdata u8 btn_stt = 0;
  14          xdata u8 check_press = 0; // nhan don hoac nhan giu
  15          xdata u8 check_hold_btn = 0;
  16          xdata u8 have_press = 0;
  17          
  18          xdata u8 flag_start = 0;
  19          u8 rec_data[6] = {0};
  20          xdata u32 U_in;
  21          xdata u32 I_in;
  22          xdata int32_t P_in;
  23          
  24          data_bl0942 *Data_Read;
  25          
  26          void RD_Init_flash(void){
  27   1          // read_all_flash();
  28   1          // rd_print("header: ");
  29   1          // RD_PRINT_HEX(Data_Read->header);
  30   1          // rd_print(" tail: ");
  31   1          // RD_PRINT_HEX(Data_Read->tail);
  32   1          // rd_print("\n");
  33   1          // if(Data_Read->header != 0x55 && Data_Read->tail != 0xaa){
  34   1          //     rd_print("init fail\n");
  35   1          //     Data_Read->header = 0x55;
  36   1          //     Data_Read->tail = 0xaa;
  37   1          // }
  38   1          // write_data_fash();
  39   1      }
  40          
  41          uint8_t get_btn(void)
  42          {
  43   1          uint8_t temp_get_btn = 0;
  44   1          if (RD_PIN_BTN == 0)
  45   1          {
  46   2              temp_get_btn = 0;
  47   2          }
  48   1          else
  49   1          {
  50   2              temp_get_btn = 1;
  51   2          }
  52   1          return temp_get_btn;
  53   1      }
  54          
C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 2   

  55          u16 get_time_ms(void)
  56          {
  57   1          return time_system;
  58   1      }
  59          void RD_Scan_Btn(void)
  60          {
  61   1          u16 temp_get_time = 0;
  62   1          temp_get_time = get_time_ms();
  63   1          WDT_Clear();
  64   1          time_scan_btn_new = temp_get_time;
  65   1          if (time_scan_btn_new < time_scan_btn_old)
  66   1              time_scan_btn_old = time_scan_btn_new; // tran
  67   1          if (time_scan_btn_new - time_scan_btn_old > 10)
  68   1          { // quet phim 10ms/1lan
  69   2              BTN_STT_NEW = get_btn();
  70   2              if (BTN_STT_NEW == 0 && BTN_STT_OLD == 1)
  71   2              { // nhan nut
  72   3                  time_press_start = temp_get_time;
  73   3                  btn_stt = 1;
  74   3              }
  75   2              else if (BTN_STT_NEW == 1 && BTN_STT_OLD == 0)
  76   2              { // nha nut
  77   3                  if (time_count_press >= 35 && time_count_press < 600)
  78   3                  {
  79   4                      if (check_hold_btn == 1)
  80   4                      {
  81   5                          rd_print("nha giu\n");
  82   5                          check_hold_btn = 0;
  83   5                      }
  84   4                      else
  85   4                      {
  86   5                          have_press = 1;
  87   5                          check_press = 1;
  88   5                      }
  89   4                  }
  90   3                  else
  91   3                  {
  92   4                      if (time_count_press >= 600)
  93   4                      {
  94   5                          rd_print("nha giu\n");
  95   5                          check_hold_btn = 0;
  96   5                      }
  97   4                  }
  98   3                  btn_stt = 0;
  99   3              }
 100   2              /*check hold btn*/
 101   2              if (btn_stt)
 102   2              {
 103   3                  if (time_press_start > temp_get_time)
 104   3                  {
 105   4                      time_count_press = (65535 - time_press_start) + temp_get_time;
 106   4                  }
 107   3                  else
 108   3                  {
 109   4                      time_count_press = temp_get_time - time_press_start;
 110   4                  }
 111   3                  if (time_count_press >= 1200)
 112   3                  {
 113   4                      have_press = 1;
 114   4                      check_press = 2;
 115   4                      time_press_start = temp_get_time - 700; // 500ms scan 1 phat
 116   4                  }
C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 3   

 117   3              }
 118   2              BTN_STT_OLD = BTN_STT_NEW;
 119   2              time_scan_btn_old = time_scan_btn_new;
 120   2          }
 121   1          /*xu ly nut nhan*/
 122   1          if (have_press)
 123   1          {
 124   2              if (check_press == 1)
 125   2              {
 126   3                  rd_print("an 1 phat\n");
 127   3                  time_start_check_num_btn = temp_get_time;
 128   3                  count_btn++;
 129   3                  check_press = 0;
 130   3              }
 131   2              else if (check_press == 2)
 132   2              {
 133   3                  rd_print("an giu ne\n");
 134   3                  count_btn = 0;
 135   3                  check_hold_btn = 1;
 136   3                  check_press = 0;
 137   3              }
 138   2      
 139   2              have_press = 0;
 140   2          }
 141   1      
 142   1          /*kiem tra so lan nhan*/
 143   1          if (time_start_check_num_btn > temp_get_time)
 144   1          {
 145   2              time_count_check_num_btn = (65535 - time_start_check_num_btn) + temp_get_time;
 146   2          }
 147   1          else
 148   1          {
 149   2              time_count_check_num_btn = temp_get_time - time_start_check_num_btn;
 150   2          }
 151   1          if (count_btn)
 152   1          {
 153   2              if (time_count_check_num_btn > 600)
 154   2              {
 155   3                  if (count_btn == 1)
 156   3                  {
 157   4                      rd_print("1 phat\n");
 158   4                  }
 159   3                  else if (count_btn == 2)
 160   3                  {
 161   4                      rd_print("2 phat\n");
 162   4                  }
 163   3                  else if (count_btn == 3)
 164   3                  {
 165   4                      rd_print("3 phat\n");
 166   4                  }
 167   3                  count_btn = 0;
 168   3                  time_count_check_num_btn = 0;
 169   3                  time_start_check_num_btn = temp_get_time;
 170   3              }
 171   2          }
 172   1          else
 173   1          {
 174   2              time_start_check_num_btn = temp_get_time;
 175   2          }
 176   1      }
 177          
 178          void RD_Unlock_Send(void)
C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 4   

 179          {
 180   1          uint8_t data_send[6] = {0};
 181   1          uint16_t CRC_Temp = (0xA8 + USR_WRPROT + 0x55);
 182   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 183   1          data_send[0] = 0xA8;
 184   1          data_send[1] = USR_WRPROT;
 185   1          data_send[2] = 0x00;
 186   1          data_send[3] = 0x00;
 187   1          data_send[4] = 0x55;
 188   1          data_send[5] = CRC_Check;
 189   1          RD_Send_String_SPI(data_send);
 190   1      }
 191          
 192          void RD_Send_Setup(uint8_t reg_addr, uint8_t *data_w)
 193          {
 194   1          uint8_t i = 0;
 195   1          uint8_t data_send[6] = {0};
 196   1          uint16_t CRC_Temp = 0xA8 + reg_addr + data_w[0] + data_w[1] + data_w[2];
 197   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 198   1          RD_Unlock_Send();
 199   1          data_send[0] = 0xA8;
 200   1          data_send[1] = reg_addr;
 201   1          data_send[2] = data_w[0];
 202   1          data_send[3] = data_w[1];
 203   1          data_send[4] = data_w[2];
 204   1          data_send[5] = CRC_Check;
 205   1          RD_Send_String_SPI(data_send);
 206   1      
 207   1      #if RD_LOG
 208   1          rd_print("data send: ");
 209   1          for (i = 0; i < 6; i++)
 210   1          {
 211   2              RD_PRINT_HEX(data_send[i]);
 212   2          }
 213   1          rd_print("\n");
 214   1      #endif
 215   1      }
 216          
 217          int32_t RD_Read_Data_Signed_SPI(uint8_t reg_addr)
 218          {
 219   1          u32 read_value = 0;
 220   1          uint8_t i = 0;
 221   1          uint8_t tx_data[6] = {0};
 222   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 223   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 224   1          tx_data[0] = 0x58;
 225   1          tx_data[1] = reg_addr;
 226   1          tx_data[2] = 0x00;
 227   1          tx_data[3] = 0x00;
 228   1          tx_data[4] = 0x00;
 229   1          tx_data[5] = 0x00; // CRC_Check;
 230   1          RD_Send_String_SPI(tx_data);
 231   1      
 232   1      #if RD_LOG
 233   1          rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
 234   1          for (i = 0; i < 6; i++)
 235   1          {
 236   2              RD_PRINT_HEX(rec_data[i]);
 237   2          }
 238   1          rd_print("\n");
 239   1      #endif
 240   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 5   

 241   1          CRC_Check = ~(CRC_Temp & 0xff);
 242   1          if (CRC_Check == rec_data[5])
 243   1          {
 244   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 245   2              memset(rec_data, 0, 6);
 246   2              if (read_value & 0x800000)
 247   2              {
 248   3                  read_value |= 0xff000000; // mo rong bit dau
 249   3              }
 250   2              rd_print("value = %ld \n", read_value);
 251   2              rd_print("-----------------------------\n");
 252   2              return read_value;
 253   2          }
 254   1          //rd_print("-----------------------------\n");
 255   1          memset(rec_data, 0, 6);
 256   1          return 0;
 257   1      }
 258          
 259          u32 RD_Read_Data_SPI(uint8_t reg_addr)
 260          { // get data ko dau
 261   1          u32 read_value = 0;
 262   1          uint8_t i = 0;
 263   1          uint8_t tx_data[6] = {0};
 264   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 265   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 266   1          tx_data[0] = 0x58;
 267   1          tx_data[1] = reg_addr;
 268   1          tx_data[2] = 0x00;
 269   1          tx_data[3] = 0x00;
 270   1          tx_data[4] = 0x00;
 271   1          tx_data[5] = 0x00; // CRC_Check;
 272   1          RD_Send_String_SPI(tx_data);
 273   1      
 274   1      #if RD_LOG
 275   1          rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
 276   1          for (i = 0; i < 6; i++)
 277   1          {
 278   2              RD_PRINT_HEX(rec_data[i]);
 279   2          }
 280   1          rd_print("\n");
 281   1      #endif
 282   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 283   1          CRC_Check = ~(CRC_Temp & 0xff);
 284   1          if (CRC_Check == rec_data[5])
 285   1          {
 286   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 287   2              memset(rec_data, 0, 6);
 288   2              rd_print("value = %lu\n", read_value);
 289   2              rd_print("-----------------------------\n");
 290   2              return read_value;
 291   2          }
 292   1          rd_print("-----------------------------\n");
 293   1          memset(rec_data, 0, 6);
 294   1          return 0;
 295   1      }
 296          
 297          void RD_setup_BL0942(void)
 298          {
 299   1          uint8_t Set_CF_ZX[3] = {0x00, 0x00, 0x23}; // 0010 0011: ZX 10, CF2 00, CF1 11
 300   1          uint8_t Set_Gain[3] = {0x00, 0x00, 0x03};
 301   1          uint8_t Set_Soft_Reset[3] = {0x5a, 0x5a, 0x5a};
 302   1          RD_Send_Setup(GAIN_CR, Set_Gain);
C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 6   

 303   1          RD_Send_Setup(SOFT_RESET, Set_Soft_Reset);
 304   1          RD_Send_Setup(REG_OT_FUNX, Set_CF_ZX);
 305   1          rd_print("SET UP OK!\n\n\n");
 306   1      }
 307          
 308          void rd_loop(void)
 309          {
 310   1          float temp_cal;
 311   1          if (flag_start == 0)
 312   1          {
 313   2              RD_Init_flash();
 314   2              RD_setup_BL0942();
 315   2              flag_start = 1;
 316   2          }
 317   1          U_in = RD_Read_Data_SPI(REG_VRMS);
 318   1          temp_cal = 2375.72118f/(73989.0f * 510.0f); // temp_U //= (1.218*(390000*5 + 510)*0.001)
 319   1          Data_Read->U_hd = U_in * temp_cal;
 320   1          rd_print("U hd: %.2f V, ", Data_Read->U_hd);
 321   1          rd_print("temp_U = %.7f\n\n", temp_cal);
 322   1      
 323   1          I_in = RD_Read_Data_SPI(REG_IRMS);
 324   1          temp_cal = 1.218 / 305978; // temp_I
 325   1          Data_Read->I_hd = (I_in * temp_cal) / 2.3506;
 326   1          rd_print("I hd: %.4f A, ", Data_Read->I_hd);
 327   1          rd_print("temp_I = %.7f\n\n", temp_cal);
 328   1      
 329   1          P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 330   1          temp_cal = 0.001604122; //=((1.218*1.218)*(390000*5 + 510))/(3537*0.001*510*1000*1000)  temp_P
 331   1          Data_Read->P_hd = P_in * temp_cal;
 332   1          rd_print("\nP hieu dung: %.3f W\n\n", Data_Read->P_hd);
 333   1      
 334   1          Data_Read->Cos_Phi = Data_Read->P_hd / (Data_Read->U_hd * Data_Read->I_hd);
 335   1          rd_print("cos phi: %.3f radian\n\n", Data_Read->Cos_Phi);
 336   1      
 337   1          // if (Data_Read->I_hd < 0.0001)
 338   1          // {
 339   1          //     Data_Read->P_hd = 0;
 340   1          //     Data_Read->Cos_Phi = 0;
 341   1          // }
 342   1          // else
 343   1          // {
 344   1          //     P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 345   1          //     temp_cal = 0.001604122; //=((1.218*1.218)*(390000*5 + 510))/(3537*0.001*510*1000*1000)  temp_P
 346   1          //     Data_Read->P_hd = P_in * temp_cal;
 347   1          //     rd_print("P hieu dung: %.3f W\n\n", Data_Read->P_hd);
 348   1      
 349   1          //     if(Data_Read->P_hd < 0 || Data_Read->P_hd > 10000) Data_Read->P_hd = 0;
 350   1          //     Data_Read->Cos_Phi = Data_Read->P_hd / (Data_Read->U_hd * Data_Read->I_hd);
 351   1          // }
 352   1      
 353   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2008    ----
   CONSTANT SIZE    =    312    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9      63
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.01   BL0942                                                                01/07/2025 16:28:25 PAGE 7   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
