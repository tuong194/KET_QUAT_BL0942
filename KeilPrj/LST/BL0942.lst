C51 COMPILER V9.01   BL0942                                                                01/04/2025 14:43:44 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BL0942
OBJECT MODULE PLACED IN .\OBJ\BL0942.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\BL0942\BL0942.c BROWSE INCDIR(..\code\BL0942) DEBUG OBJECTEXTEND
                    - PRINT(.\LST\BL0942.lst) OBJECT(.\OBJ\BL0942.obj)

line level    source

   1          #include "./BL0942.H"  // SPI hỗ trợ max 900kHz
   2          
   3          extern u16 time_system;
   4          xdata u16 time_scan_btn_old = 0;
   5          xdata u16 time_scan_btn_new = 0;
   6          xdata u16 time_press_start = 0;
   7          xdata u16 time_count_press = 0;
   8          xdata u16 time_start_check_num_btn = 0;
   9          xdata u16 time_count_check_num_btn = 0;
  10          xdata u8 count_btn = 0;  // so lan nhan 
  11          xdata u8 BTN_STT_NEW = 0;
  12          xdata u8 BTN_STT_OLD = 0;
  13          xdata u8 btn_stt = 0;
  14          xdata u8 check_press = 0; // nhan don hoac nhan giu
  15          xdata u8 check_hold_btn = 0;
  16          xdata u8 have_press = 0;
  17          
  18          xdata u8 flag_start = 0;
  19          u8 rec_data[6] = {0};
  20          
  21          
  22          uint8_t get_btn(void){
  23   1          uint8_t temp_get_btn = 0;
  24   1          if(RD_PIN_BTN==0){
  25   2              temp_get_btn=0;
  26   2          }else{
  27   2              temp_get_btn = 1;
  28   2          }
  29   1          return temp_get_btn;
  30   1      }
  31          
  32          u16 get_time_ms(void){
  33   1          return time_system;
  34   1      }
  35          void RD_Scan_Btn(void){
  36   1          u16 temp_get_time = 0;
  37   1          temp_get_time = get_time_ms();
  38   1          WDT_Clear();
  39   1          time_scan_btn_new = temp_get_time;
  40   1          if(time_scan_btn_new < time_scan_btn_old) time_scan_btn_old = time_scan_btn_new; // tran
  41   1          if(time_scan_btn_new - time_scan_btn_old > 10){ // quet phim 10ms/1lan
  42   2              BTN_STT_NEW = get_btn();
  43   2              if(BTN_STT_NEW == 0 && BTN_STT_OLD == 1){ // nhan nut
  44   3                  time_press_start = temp_get_time;
  45   3                  btn_stt = 1;
  46   3              }else if(BTN_STT_NEW == 1 && BTN_STT_OLD == 0){ // nha nut
  47   3                  if(time_count_press >= 35 && time_count_press < 600){
  48   4                      if(check_hold_btn == 1){ 
  49   5                          rd_print("nha giu\n");
  50   5                          check_hold_btn = 0;
  51   5                      }else{
  52   5                          have_press = 1;
  53   5                          check_press = 1;
  54   5                      }
C51 COMPILER V9.01   BL0942                                                                01/04/2025 14:43:44 PAGE 2   

  55   4                  }else{
  56   4                      if(time_count_press >= 600){
  57   5                          rd_print("nha giu\n");
  58   5                          check_hold_btn = 0;
  59   5                      }
  60   4                  }
  61   3                  btn_stt = 0;
  62   3              }
  63   2              /*check hold btn*/
  64   2              if(btn_stt){
  65   3                  if(time_press_start > temp_get_time){
  66   4                      time_count_press = (65535 - time_press_start) + temp_get_time;
  67   4                  }else{
  68   4                      time_count_press = temp_get_time - time_press_start;
  69   4                  }
  70   3                  if(time_count_press >= 1200){
  71   4                      have_press = 1;
  72   4                      check_press = 2;
  73   4                      time_press_start = temp_get_time - 700; // 500ms scan 1 phat
  74   4                  }
  75   3              }
  76   2              BTN_STT_OLD = BTN_STT_NEW;
  77   2              time_scan_btn_old = time_scan_btn_new;
  78   2          }
  79   1          /*xu ly nut nhan*/
  80   1          if(have_press){
  81   2              if(check_press == 1){
  82   3                  rd_print("an 1 phat\n");
  83   3                  time_start_check_num_btn = temp_get_time;
  84   3                  count_btn++;
  85   3                  check_press = 0;
  86   3              }else if(check_press == 2){
  87   3                  rd_print("an giu ne\n");
  88   3                  count_btn = 0;
  89   3                  check_hold_btn = 1;
  90   3                  check_press = 0;
  91   3              }
  92   2              
  93   2              have_press = 0;
  94   2          }
  95   1      
  96   1          /*kiem tra so lan nhan*/
  97   1          if(time_start_check_num_btn > temp_get_time){
  98   2              time_count_check_num_btn = (65535 - time_start_check_num_btn) + temp_get_time;
  99   2          }else{
 100   2              time_count_check_num_btn = temp_get_time - time_start_check_num_btn;
 101   2          }
 102   1          if(count_btn){
 103   2              if(time_count_check_num_btn > 600){
 104   3                  if(count_btn == 1){
 105   4                      rd_print("1 phat\n");
 106   4                  }else if(count_btn == 2){
 107   4                      rd_print("2 phat\n");
 108   4                  }else if(count_btn == 3){
 109   4                      rd_print("3 phat\n");
 110   4                  }
 111   3                  count_btn = 0;
 112   3                  time_count_check_num_btn = 0;
 113   3                  time_start_check_num_btn = temp_get_time;
 114   3              }
 115   2          }else{
 116   2              time_start_check_num_btn = temp_get_time;
C51 COMPILER V9.01   BL0942                                                                01/04/2025 14:43:44 PAGE 3   

 117   2          }
 118   1          
 119   1      }
 120          
 121          void RD_Unlock_Send(void){
 122   1          uint8_t data_send[6] = {0};
 123   1          uint16_t CRC_Temp = (0xA8 + USR_WRPROT + 0x55);
 124   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 125   1          data_send[0] = 0xA8;
 126   1          data_send[1] = USR_WRPROT;
 127   1          data_send[2] = 0x00;
 128   1          data_send[3] = 0x00;
 129   1          data_send[4] = 0x55;
 130   1          data_send[5] = CRC_Check;
 131   1          RD_Send_String_SPI(data_send);
 132   1      }
 133          
 134          void RD_Write_Data(uint8_t reg_addr, uint8_t *data_w){
 135   1          uint8_t i =0;
 136   1          uint8_t data_send[6] = {0};
 137   1          uint16_t CRC_Temp = 0xA8 + reg_addr + data_w[0] + data_w[1] + data_w[2];
 138   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 139   1          data_send[0] = 0xA8;
 140   1          data_send[1] = reg_addr;
 141   1          data_send[2] = data_w[0];
 142   1          data_send[3] = data_w[1];
 143   1          data_send[4] = data_w[2];
 144   1          data_send[5] = CRC_Check;
 145   1          RD_Send_String_SPI(data_send);
 146   1      
 147   1      #if RD_LOG 
 148   1          rd_print("data send: ");
 149   1          for(i=0;i<6;i++){
 150   2              RD_PRINT_HEX(data_send[i]);
 151   2          }
 152   1          rd_print("\n");
 153   1      #endif
 154   1      }
 155          
 156          
 157          void RD_Read_Data_SPI(uint8_t reg_addr){  // get data ko dau
 158   1          u32 V_RMS = 0;
 159   1          float temp_U = 0;
 160   1          u32 RD_U_HD = 0;
 161   1              uint8_t i = 0;
 162   1          uint8_t tx_data[6] = {0};
 163   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 164   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 165   1          tx_data[0] = 0x58;
 166   1          tx_data[1] = reg_addr;
 167   1          tx_data[2] = 0x00;
 168   1          tx_data[3] = 0x00;
 169   1          tx_data[4] = 0x00;
 170   1          tx_data[5] = 0x00;//CRC_Check;
 171   1          RD_Send_String_SPI(tx_data);
 172   1            
 173   1      #if RD_LOG
 174   1          rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
 175   1          for(i=0; i<6; i++){
 176   2             RD_PRINT_HEX(rec_data[i]);
 177   2          }
 178   1          rd_print("\n");  
C51 COMPILER V9.01   BL0942                                                                01/04/2025 14:43:44 PAGE 4   

 179   1      #endif
 180   1          V_RMS = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 181   1          temp_U = 2375.72118 / (73989*510);
 182   1          RD_U_HD = V_RMS*temp_U;
 183   1          //rd_print("temp U : %.7f \n", temp_U);
 184   1          rd_print("VRMS = %lu\n", V_RMS);
 185   1          rd_print("U hieu dung : %ld V", RD_U_HD);
 186   1          rd_print("\n------------------------\n\n");
 187   1          memset(rec_data, 0, 6);
 188   1           
 189   1          /*get data*/
 190   1          //CRC_Temp = 0x58 + reg_addr + rx_data[2] + rx_data[3] + rx_data[4];
 191   1          //CRC_Check = ~(CRC_Temp & 0xff);
 192   1          // if(CRC_Check == rx_data[5]){
 193   1          //     data_read = (rx_data[2] << 16) | (rx_data[3] << 8) | (rx_data[4]) ;
 194   1          //     rd_print("value: %ld\n", data_read);
 195   1          //     return data_read;
 196   1          // }
 197   1      }
 198          
 199          void RD_setup_BL0942(void){
 200   1              uint8_t Set_CF_ZX[3] ={0x00,0x00,0x23}; // 0010 0011: ZX 10, CF2 00, CF1 11
 201   1              uint8_t Set_Gain[3] ={0x00,0x00,0x03};
 202   1              uint8_t Set_Soft_Reset[3] ={0x5a,0x5a,0x5a};
 203   1              RD_Write_Data(GAIN_CR, Set_Gain);
 204   1              RD_Write_Data(SOFT_RESET, Set_Soft_Reset);
 205   1              RD_Write_Data(REG_OT_FUNX, Set_CF_ZX);
 206   1      }
 207          
 208          void rd_loop(void){
 209   1          if (flag_start == 0)
 210   1          {
 211   2              RD_setup_BL0942();
 212   2              flag_start = 1;
 213   2          }
 214   1          RD_Read_Data_SPI(REG_VRMS);
 215   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1228    ----
   CONSTANT SIZE    =    186    ----
   XDATA SIZE       =     20    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      49
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
