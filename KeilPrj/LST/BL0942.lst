C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE BL0942
OBJECT MODULE PLACED IN .\OBJ\BL0942.obj
COMPILER INVOKED BY: C:\Keil_v4\C51\BIN\C51.EXE ..\code\BL0942\BL0942.c BROWSE INCDIR(..\code\BL0942) DEBUG OBJECTEXTEND
                    - PRINT(.\LST\BL0942.lst) OBJECT(.\OBJ\BL0942.obj)

line level    source

   1          #include "./BL0942.H" // SPI hỗ trợ max 900kHz
   2          
   3          extern u16 time_system;
   4          u16 rd_time_tick = 0;
   5          u8 select_led_blink = RD_NONE;
   6          xdata u16 time_scan_btn_old = 0;
   7          xdata u16 time_scan_btn_new = 0;
   8          xdata u16 time_press_start = 0;
   9          xdata u16 time_count_press = 0;
  10          xdata u16 time_start_check_num_btn = 0;
  11          xdata u16 time_count_check_num_btn = 0;
  12          xdata u8 count_btn = 0; // so lan nhan
  13          xdata u8 BTN_STT_NEW = 0;
  14          xdata u8 BTN_STT_OLD = 0;
  15          xdata u8 btn_stt = 0;
  16          xdata u8 check_press = 0; // nhan don hoac nhan giu
  17          xdata u8 check_hold_btn = 0;
  18          xdata u8 have_press = 0;
  19          
  20          xdata u8 flag_start = 0;
  21          u8 rec_data[6] = {0};
  22          xdata u32 U_in;
  23          xdata u32 I_in;
  24          xdata int32_t P_in;
  25          xdata u16 temp_time_check_stuck = 0;
  26          xdata u16 start_time_check_stuck = 0;
  27          xdata u8 flag_start_check_stuck = 0;
  28          xdata u16 rd_time_loop = 0;
  29          
  30          xdata data_bl0942_t data_bl0942 = {0};
  31          //data_bl0942_t *Data_Read =&data_bl0942;
  32          data_flash_t *Read_Flash; 
  33          
  34          void Blink_Led(u8 LED_PIN, u8 count_blink){
  35   1          static u8 count = 0;
  36   1          if(rd_exceed_ms(rd_time_tick, 200) && select_led_blink != RD_NONE){
  37   2              if(LED_PIN == LED_G){
  38   3                  BLINK_LED(RD_LED_G);
  39   3              }else if(LED_PIN == LED_R){
  40   3                  BLINK_LED(RD_LED_R);
  41   3              }     
  42   2              count++;
  43   2              rd_time_tick = get_time_ms();
  44   2              if(rd_time_tick >= 65534) rd_time_tick = 0;
  45   2              if(count == count_blink*2){
  46   3                  select_led_blink = RD_NONE;
  47   3                  count = 0;
  48   3              }
  49   2          }
  50   1      }
  51          
  52          void Blink_Led_Err(void){
  53   1          select_led_blink = LED_R;
  54   1          Blink_Led(LED_R, 3);
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 2   

  55   1      }
  56          
  57          void Blink_Led_Config(void){
  58   1          if(!Read_Flash->check_stuck_fan && select_led_blink == LED_G) 
  59   1              Blink_Led(LED_G, 3);
  60   1      }
  61          
  62          void Blink_Led_Start(void){
  63   1          u8 i =0;
  64   1          OFF_LED(RD_LED_R);
  65   1          OFF_LED(RD_LED_G);
  66   1          for(i = 0; i< 6; i++){
  67   2              BLINK_LED(RD_LED_R);
  68   2              BLINK_LED(RD_LED_G);
  69   2              DelayXms(500);
  70   2          }
  71   1      }
  72          
  73          void RD_Init_flash(void){
  74   1          read_all_flash();
  75   1          rd_print("header: "); RD_PRINT_HEX(Read_Flash->header);
  76   1          rd_print("tail: "); RD_PRINT_HEX(Read_Flash->tail);
  77   1          rd_print("\n");
  78   1          if(Read_Flash->header != 0x55 && Read_Flash->tail != 0xaa){
  79   2              rd_print("init flash fail\n");
  80   2              Read_Flash->header = 0x55;
  81   2              Read_Flash->tail = 0xaa;
  82   2              Read_Flash->check_stuck_fan = 0;
  83   2              Read_Flash->P_old = 0;//20;
  84   2              Read_Flash->P_stuck = Read_Flash->P_old;
  85   2              Read_Flash->I_old = 0;//0.0992;
  86   2              Read_Flash->I_stuck = Read_Flash->I_old;
  87   2              Read_Flash->U_old = 0; // 220;
  88   2              Read_Flash->relay_stt = 1;
  89   2          }else{
  90   2              rd_print("init flash OK\n");
  91   2          }
  92   1          write_data_fash();
  93   1      }
  94          
  95          uint8_t get_btn(void)
  96          {
  97   1          uint8_t temp_get_btn = 0;
  98   1          if (RD_PIN_BTN == 0)
  99   1          {
 100   2              temp_get_btn = 0;
 101   2          }
 102   1          else
 103   1          {
 104   2              temp_get_btn = 1;
 105   2          }
 106   1          return temp_get_btn;
 107   1      }
 108          
 109          u16 get_time_ms(void)
 110          {
 111   1          return time_system;
 112   1      }
 113          void RD_Scan_Btn(void)
 114          {
 115   1          u16 temp_get_time = 0;
 116   1          temp_get_time = get_time_ms();
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 3   

 117   1          WDT_Clear();
 118   1          time_scan_btn_new = temp_get_time;
 119   1          if (time_scan_btn_new < time_scan_btn_old)
 120   1              time_scan_btn_old = time_scan_btn_new; // tran
 121   1          if (time_scan_btn_new - time_scan_btn_old > 10)
 122   1          { // quet phim 10ms/1lan
 123   2              BTN_STT_NEW = get_btn();
 124   2              if (BTN_STT_NEW == 0 && BTN_STT_OLD == 1)
 125   2              { // nhan nut
 126   3                  time_press_start = temp_get_time;
 127   3                  btn_stt = 1;
 128   3              }
 129   2              else if (BTN_STT_NEW == 1 && BTN_STT_OLD == 0)
 130   2              { // nha nut
 131   3                  if (time_count_press >= 35 && time_count_press < 600)
 132   3                  {
 133   4                      if (check_hold_btn == 1)
 134   4                      {
 135   5                          rd_print("nha giu\n");
 136   5                          check_hold_btn = 0;
 137   5                      }
 138   4                      else
 139   4                      {
 140   5                          have_press = 1;
 141   5                          check_press = 1;
 142   5                      }
 143   4                  }
 144   3                  else
 145   3                  {
 146   4                      if (time_count_press >= 600)
 147   4                      {
 148   5                          rd_print("nha giu\n");
 149   5                          check_hold_btn = 0;
 150   5                      }
 151   4                  }
 152   3                  btn_stt = 0;
 153   3              }
 154   2              /*check hold btn*/
 155   2              if (btn_stt)
 156   2              {
 157   3                  if (time_press_start > temp_get_time)
 158   3                  {
 159   4                      time_count_press = (65535 - time_press_start) + temp_get_time;
 160   4                  }
 161   3                  else
 162   3                  {
 163   4                      time_count_press = temp_get_time - time_press_start;
 164   4                  }
 165   3                  if (time_count_press >= 3000)
 166   3                  {
 167   4                      have_press = 1;
 168   4                      check_press = 2;
 169   4                      time_press_start = temp_get_time - 1000; // (3000 - 1000)ms scan 1 phat
 170   4                  }
 171   3              }
 172   2              BTN_STT_OLD = BTN_STT_NEW;
 173   2              time_scan_btn_old = time_scan_btn_new;
 174   2          }
 175   1          /*xu ly nut nhan*/
 176   1          if (have_press)
 177   1          {
 178   2              if (check_press == 1)
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 4   

 179   2              {
 180   3                  rd_print("an ne\n");
 181   3                  time_start_check_num_btn = temp_get_time;
 182   3                  count_btn++;
 183   3                  check_press = 0;
 184   3              }
 185   2              else if (check_press == 2)
 186   2              {
 187   3                  
 188   3                  config_P_I_Stuck();
 189   3                  select_led_blink = LED_G;   
 190   3                  count_btn = 0;
 191   3                  check_hold_btn = 1;
 192   3                  check_press = 0;
 193   3              }
 194   2              have_press = 0;
 195   2          }
 196   1      
 197   1          /*kiem tra so lan nhan*/
 198   1          if (time_start_check_num_btn > temp_get_time)
 199   1          {
 200   2              time_count_check_num_btn = (65535 - time_start_check_num_btn) + temp_get_time;
 201   2          }
 202   1          else
 203   1          {
 204   2              time_count_check_num_btn = temp_get_time - time_start_check_num_btn;
 205   2          }
 206   1          if (count_btn)
 207   1          {
 208   2              if (time_count_check_num_btn > 600)
 209   2              {
 210   3                  if (count_btn == 1)
 211   3                  {
 212   4                      rd_print("1 phat\n");
 213   4                  }
 214   3                  else if (count_btn == 2)
 215   3                  {
 216   4                      rd_print("2 phat\n");
 217   4                  }
 218   3                  else if (count_btn == 3)
 219   3                  {
 220   4                      rd_print("reset chip ne\n");
 221   4                      select_led_blink = LED_R;
 222   4                      Read_Flash->check_stuck_fan = 0;
 223   4                      flag_start_check_stuck = 0;
 224   4                      OFF_LED(RD_LED_R);
 225   4                      ON_RELAY();
 226   4                  }
 227   3                  count_btn = 0;
 228   3                  time_count_check_num_btn = 0;
 229   3                  time_start_check_num_btn = temp_get_time;
 230   3              }
 231   2          }
 232   1          else
 233   1          {
 234   2              time_start_check_num_btn = temp_get_time;
 235   2          }
 236   1      }
 237          
 238          void RD_Unlock_Send(void)
 239          {
 240   1          uint8_t data_send[6] = {0};
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 5   

 241   1          uint16_t CRC_Temp = (0xA8 + USR_WRPROT + 0x55);
 242   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 243   1          data_send[0] = 0xA8;
 244   1          data_send[1] = USR_WRPROT;
 245   1          data_send[2] = 0x00;
 246   1          data_send[3] = 0x00;
 247   1          data_send[4] = 0x55;
 248   1          data_send[5] = CRC_Check;
 249   1          RD_Send_String_SPI(data_send);
 250   1      }
 251          
 252          void RD_Send_Setup(uint8_t reg_addr, uint8_t *data_w)
 253          {
 254   1          uint8_t i = 0;
 255   1          uint8_t data_send[6] = {0};
 256   1          uint16_t CRC_Temp = 0xA8 + reg_addr + data_w[0] + data_w[1] + data_w[2];
 257   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 258   1          RD_Unlock_Send();
 259   1          data_send[0] = 0xA8;
 260   1          data_send[1] = reg_addr;
 261   1          data_send[2] = data_w[0];
 262   1          data_send[3] = data_w[1];
 263   1          data_send[4] = data_w[2];
 264   1          data_send[5] = CRC_Check;
 265   1          RD_Send_String_SPI(data_send);
 266   1      
 267   1      #if RD_LOG
                  rd_print("data send: ");
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(data_send[i]);
                  }
                  rd_print("\n");
              #endif
 275   1      }
 276          
 277          int32_t RD_Read_Data_Signed_SPI(uint8_t reg_addr)
 278          {
 279   1          u32 read_value = 0;
 280   1          uint8_t i = 0;
 281   1          uint8_t tx_data[6] = {0};
 282   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 283   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 284   1          tx_data[0] = 0x58;
 285   1          tx_data[1] = reg_addr;
 286   1          tx_data[2] = 0x00;
 287   1          tx_data[3] = 0x00;
 288   1          tx_data[4] = 0x00;
 289   1          tx_data[5] = 0x00; // CRC_Check;
 290   1          RD_Send_String_SPI(tx_data);
 291   1      
 292   1      #if RD_LOG
                  rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(rec_data[i]);
                  }
                  rd_print("\n");
              #endif
 300   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 301   1          CRC_Check = ~(CRC_Temp & 0xff);
 302   1          if (CRC_Check == rec_data[5])
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 6   

 303   1          {
 304   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 305   2              memset(rec_data, 0, 6);
 306   2              if (read_value & 0x800000)
 307   2              {
 308   3                  read_value |= 0xff000000; // mo rong bit dau
 309   3              }
 310   2              //rd_print("value = %ld \n", read_value);
 311   2              //rd_print("-----------------------------\n");
 312   2              return read_value;
 313   2          }
 314   1          memset(rec_data, 0, 6);
 315   1          return 0;
 316   1      }
 317          
 318          u32 RD_Read_Data_SPI(uint8_t reg_addr)
 319          { // get data ko dau
 320   1          u32 read_value = 0;
 321   1          uint8_t i = 0;
 322   1          uint8_t tx_data[6] = {0};
 323   1          uint16_t CRC_Temp = 0x58 + reg_addr;
 324   1          uint8_t CRC_Check = ~(CRC_Temp & 0xff);
 325   1          tx_data[0] = 0x58;
 326   1          tx_data[1] = reg_addr;
 327   1          tx_data[2] = 0x00;
 328   1          tx_data[3] = 0x00;
 329   1          tx_data[4] = 0x00;
 330   1          tx_data[5] = 0x00; // CRC_Check;
 331   1          RD_Send_String_SPI(tx_data);
 332   1      
 333   1      #if RD_LOG
                  rd_print("Data rec reg 0x%02X: ", (unsigned int)reg_addr);
                  for (i = 0; i < 6; i++)
                  {
                      RD_PRINT_HEX(rec_data[i]);
                  }
                  rd_print("\n");
              #endif
 341   1          CRC_Temp = 0x58 + reg_addr + rec_data[2] + rec_data[3] + rec_data[4];
 342   1          CRC_Check = ~(CRC_Temp & 0xff);
 343   1          if (CRC_Check == rec_data[5])
 344   1          {
 345   2              read_value = ((u32)rec_data[2] << 16) | ((u32)rec_data[3] << 8) | ((u32)rec_data[4]);
 346   2              memset(rec_data, 0, 6);
 347   2      #if RD_LOG
                      rd_print("value = %lu\n", read_value);
                      rd_print("-----------------------------\n");
              #endif
 351   2              return read_value;
 352   2          }
 353   1          //rd_print("-----------------------------\n");
 354   1          memset(rec_data, 0, 6);
 355   1          return 0;
 356   1      }
 357          
 358          u8 rd_exceed_ms(u16 ref, u16 span_ms){
 359   1          return ((get_time_ms() - ref) >= span_ms);
 360   1      }
 361          
 362          void RD_setup_BL0942(void)
 363          {
 364   1          uint8_t Set_CF_ZX[3] = {0x00, 0x00, 0x23}; // 0010 0011: ZX 10, CF2 00, CF1 11
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 7   

 365   1          uint8_t Set_Gain[3] = {0x00, 0x00, 0x03};
 366   1          uint8_t Set_Soft_Reset[3] = {0x5a, 0x5a, 0x5a};
 367   1          RD_Send_Setup(GAIN_CR, Set_Gain);
 368   1          RD_Send_Setup(SOFT_RESET, Set_Soft_Reset);
 369   1          RD_Send_Setup(REG_OT_FUNX, Set_CF_ZX);
 370   1          rd_print("SET UP OK!\n\n\n");
 371   1      }
 372          
 373          void read_UIP(void){
 374   1          float temp_cal;
 375   1          U_in = RD_Read_Data_SPI(REG_VRMS);
 376   1          temp_cal = 2375.72118f/(73989.0f * 510.0f); // temp_U //= (1.218*(390000*5 + 510)*0.001)
 377   1          data_bl0942.U_hd = U_in * temp_cal;
 378   1          rd_print("U hd: %.2f V, \n", data_bl0942.U_hd);
 379   1          //DelayXms(200);
 380   1      
 381   1          I_in = RD_Read_Data_SPI(REG_IRMS);
 382   1          temp_cal = 1.218 / 305978; // temp_I
 383   1          data_bl0942.I_hd = (I_in * temp_cal);
 384   1          rd_print("I hd: %.4f A, \n", data_bl0942.I_hd);
 385   1          //DelayXms(200);
 386   1      
 387   1      /*  Test 
 388   1          P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 389   1          temp_cal = 0.001604122; 
 390   1          data_bl0942.P_hd = P_in * temp_cal;
 391   1          rd_print("P hieu dung: %.3f W \n", data_bl0942.P_hd);
 392   1      
 393   1          data_bl0942.Cos_Phi = (data_bl0942.P_hd) / ((data_bl0942.U_hd) * (data_bl0942.I_hd));
 394   1          rd_print("Cos phi : %.3f \n\n", data_bl0942.Cos_Phi);
 395   1      */
 396   1          if (data_bl0942.I_hd < 0.0001)
 397   1          {
 398   2              data_bl0942.P_hd = 0;
 399   2              data_bl0942.Cos_Phi = 0;
 400   2          }
 401   1          else
 402   1          {
 403   2              P_in = RD_Read_Data_Signed_SPI(REG_WATT);
 404   2              temp_cal = 0.001604122; //=((1.218*1.218)*(390000*5 + 510))/(3537*0.001*510*1000*1000)  temp_P
 405   2              data_bl0942.P_hd = P_in * temp_cal;
 406   2              if(data_bl0942.P_hd < 0 || data_bl0942.P_hd > 10000) data_bl0942.P_hd = 0;
 407   2              rd_print("P hieu dung: %.3f W\n\n", data_bl0942.P_hd);
 408   2       
 409   2          }
 410   1      }
 411          void config_P_I_Stuck(void){
 412   1          Read_Flash->P_old = data_bl0942.P_hd;
 413   1          Read_Flash->P_stuck = Read_Flash->P_old;
 414   1          Read_Flash->I_old = data_bl0942.I_hd;
 415   1          Read_Flash->I_stuck = Read_Flash->I_old;
 416   1          Read_Flash->U_old = data_bl0942.U_hd;
 417   1          Read_Flash->Z = data_bl0942.U_hd / data_bl0942.I_hd;
 418   1          write_data_fash();
 419   1          rd_print("config P ket: %.3f W\n\n\n", Read_Flash->P_stuck);
 420   1      }
 421          
 422          void update_Pstuck_by_U(void){
 423   1          data_bl0942.Cos_Phi = data_bl0942.P_hd / (data_bl0942.U_hd * data_bl0942.I_hd);
 424   1          if(CALC_EXCEED(data_bl0942.U_hd, Read_Flash->U_old) > 5){  // U tang 5%
 425   2              Read_Flash->I_old = data_bl0942.I_hd;
 426   2              Read_Flash->I_stuck = Read_Flash->I_old;
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 8   

 427   2              Read_Flash->P_old = data_bl0942.P_hd;//(data_bl0942.U_hd * data_bl0942.U_hd * data_bl0942.Cos_Phi)
             - / Read_Flash->Z;
 428   2              Read_Flash->P_stuck = Read_Flash->P_old;
 429   2              Read_Flash->U_old = data_bl0942.U_hd;
 430   2              write_data_fash();
 431   2              rd_print("P ket up: %.3f W\n\n", Read_Flash->P_stuck);
 432   2          }else if(CALC_LESS(data_bl0942.U_hd, Read_Flash->U_old) > 5){ // U giam 5%
 433   2              Read_Flash->I_old = data_bl0942.I_hd;
 434   2              Read_Flash->I_stuck = Read_Flash->I_old;
 435   2              Read_Flash->P_old = data_bl0942.P_hd;//(data_bl0942.U_hd * data_bl0942.U_hd * data_bl0942.Cos_Phi)
             - / Read_Flash->Z;
 436   2              Read_Flash->P_stuck = Read_Flash->P_old;
 437   2              Read_Flash->U_old = data_bl0942.U_hd;
 438   2              write_data_fash();
 439   2              rd_print("P ket down: %.3f W\n\n", Read_Flash->P_stuck);
 440   2          }
 441   1          else if((CALC_EXCEED(data_bl0942.U_hd, Read_Flash->U_old) < 1) || (CALC_LESS(data_bl0942.U_hd, Read_Fl
             -ash->U_old) < 1)){
 442   2              Read_Flash->U_old = data_bl0942.U_hd;
 443   2              //Read_Flash->I_old = data_bl0942.I_hd;
 444   2          }
 445   1      }
 446          
 447          void loop_check_stuck_fan(void){
 448   1          if(data_bl0942.P_hd > 10 && Read_Flash->P_old > 0){
 449   2              if(start_time_check_stuck >= 65530) start_time_check_stuck = 0 ;
 450   2              if(Read_Flash->check_stuck_fan == 0 && Read_Flash->P_old > 0){
 451   3                  if(!flag_start_check_stuck){
 452   4                      if(rd_exceed_ms(start_time_check_stuck, TIMEOUT_START_CHECK)){
 453   5                          start_time_check_stuck = temp_time_check_stuck;
 454   5                          flag_start_check_stuck = 1;
 455   5                          rd_print("start check stuck\n\n\n");
 456   5                      }
 457   4                  }else{
 458   4                      float temp_check_P = 0;
 459   4                      update_Pstuck_by_U();
 460   4                      if(data_bl0942.P_hd > Read_Flash->P_old){
 461   5                          if(data_bl0942.I_hd > Read_Flash->I_old){
 462   6                              if(((data_bl0942.I_hd - Read_Flash->I_old) / Read_Flash->I_stuck)*100 >= 1 ){  // 
             -I > 1%
 463   7                                  temp_check_P = ((data_bl0942.P_hd - Read_Flash->P_old) / Read_Flash->P_stuck)*
             -100;
 464   7                              }
 465   6                          }
 466   5                          if(data_bl0942.P_hd > Read_Flash->P_stuck && data_bl0942.I_hd > Read_Flash->I_stuck){
 467   6                              Read_Flash->P_old = Read_Flash->P_stuck;
 468   6                              Read_Flash->I_old = Read_Flash->I_stuck;
 469   6                          }
 470   5                      }else{
 471   5                          // neu cong suat giam 2%
 472   5                          if(((Read_Flash->P_old - data_bl0942.P_hd)/Read_Flash->P_old)*100 < 2){
 473   6                              Read_Flash->P_old = data_bl0942.P_hd;
 474   6                              Read_Flash->I_old = data_bl0942.I_hd;
 475   6                          } 
 476   5                      }
 477   4                       
 478   4                      if(temp_check_P >= 20){
 479   5                          Read_Flash->check_stuck_fan = 1;
 480   5                          rd_print("delta P: %.2f \n", temp_check_P);
 481   5                          rd_print("VUOT MUC PICKLEBALL\n\n\n");
 482   5                          OFF_RELAY();
 483   5                      }
C51 COMPILER V9.01   BL0942                                                                01/11/2025 14:34:28 PAGE 9   

 484   4                  }
 485   3              }else{
 486   3                  start_time_check_stuck = temp_time_check_stuck;
 487   3              }
 488   2          }else{
 489   2              start_time_check_stuck = temp_time_check_stuck;
 490   2              flag_start_check_stuck = 0;
 491   2          }
 492   1      }
 493          
 494          void rd_start_init(void){
 495   1          ON_RELAY();
 496   1          Blink_Led_Start();
 497   1          DelayXms(3000);
 498   1      }
 499          
 500          void rd_loop(void)
 501          {
 502   1          temp_time_check_stuck = get_time_ms();
 503   1          if (flag_start == 0)
 504   1          {
 505   2              RD_Init_flash();
 506   2              RD_setup_BL0942();
 507   2              rd_time_loop = get_time_ms();
 508   2              flag_start = 1;
 509   2              rd_print("P ket init: %.3f W\n", Read_Flash->P_stuck);  
 510   2          }
 511   1          RD_Scan_Btn();
 512   1          Blink_Led_Config();
 513   1          if(rd_exceed_ms(rd_time_loop, TIME_LOOP)){
 514   2              read_UIP();
 515   2              loop_check_stuck_fan();
 516   2              rd_time_loop = get_time_ms();
 517   2              if(rd_time_loop >= 65530) rd_time_loop = 0;
 518   2          }
 519   1          if(Read_Flash->check_stuck_fan == 1){
 520   2              Blink_Led_Err();
 521   2          }
 522   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3727    ----
   CONSTANT SIZE    =    350    ----
   XDATA SIZE       =     55    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      64
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
